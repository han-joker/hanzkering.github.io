<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go语言的包管理]]></title>
    <url>%2Fgo%2Fgo-package%2F</url>
    <content type="text"><![CDATA[1 概述Go 语言的源码复用建立在包（package）基础之上。包通过 package, import, GOPATH 操作完成。 2 main包Go 语言的入口 main() 函数所在的包（package）叫 main，main 包想要引用别的代码，需要import导入！ 3 包定义，packageGo 语言的包与文件夹一一对应，同一个目录下的所有.go文件的第一行添加 包定义，以标记该文件归属的包，演示语法：1package 包名 包需要满足： 一个目录下的同级文件归属一个包。 包名可以与其目录不同名。 包名为 main 的包为应用程序的入口包，其他包不能使用。 包可以嵌套定义，对应的就是嵌套目录，但包名应该与所在的目录一致，例如：12345678// 文件：foo/bar/tool.go中package bar// 可以被导出的函数func FuncPublic() &#123;&#125;// 不可以被导出的函数func funcPrivate() &#123;&#125; 包中，通过标识符首字母是否大写，来确定是否可以被导出。首字母大写才可以被导出，视为 public 公共的资源。 4 导入包，import要引用其他包，可以使用 import 关键字，可以单个导入或者批量导入，语法演示：1234567// 单个导入import &quot;package&quot;// 批量导入import ( &quot;package1&quot; &quot;package2&quot; ) 导入时，可以为包定义别名，语法演示：123456import ( p1 &quot;package1&quot; p2 &quot;package2&quot; )// 使用时p1.Method() 以上测试请使用系统包测试。若需要导入自定义包，需要设置GOPATH环境变量。 4 GOPATH环境变量import导入时，会从GO的安装目录（也就是GOROOT环境变量设置的目录）和GOPATH环境变量设置的目录中，检索 src/package 来导入包。如果不存在，则导入失败。GOROOT，就是GO内置的包所在的位置。GOPATH，就是我们自己定义的包的位置。 通常我们在开发Go项目时，调试或者编译构建时，需要设置GOPATH指向我们的项目目录，目录中的src目录中的包就可以被导入了：例如，我么的项目目录为： D:\projects\goProject，那么我么就需要将我们的源代码放在 D:\projects\goProject\src 下，同时设置GOPATH为 D:\projects\goProject。设置GOPATH的方案有： windows 通过 系统-&gt;系统信息-&gt;高级系统设置-&gt;环境变量 中完成设置。 windows 中通过 CMD 或者 powershell 也可以完成设置。通常是临时有效的，CMD或者powershell关闭失效！ 123456CMD：set GOPATH=D:\projects\goProjectset GOPATH 可以查看powershell：$env:GOPATH=&quot;D:\projects\goProject&quot;$env:GOPATH 可以查看 linux 通过 /etc/profile 进行设置 5 init() 包初始化可以在源码中，定义 init() 函数。此函数会在包被导入时执行，例如如果是在 main 中导入包，包中存在 init()，那么 init() 中的代码会在 main() 函数执行前执行，用于初始化包所需要的特定资料。例如：包源码：1234567src/userPackage/tool.gopackage userPackageimport &quot;fmt&quot;func init() &#123; fmt.Println(&quot;tool init&quot;)&#125; 主函数源码：1234567891011src/main.gopackage mainimport ( &quot;userPackage&quot; )func main() &#123; fmt.Println(&quot;main run&quot;) // 使用userPackage userPackage.SomeFunc()&#125; 执行时，会先输出 “tool init”，再输出 “main run”。 如果仅仅需要导入包时执行初始化操作，并不需要使用包内的其他函数，常量等资源。则可以在导入包时，匿名导入：123import ( _ &quot;userPackage&quot; ) 使用下划线作为包的别名，会仅仅执行init() 完！]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的字符串处理]]></title>
    <url>%2Fgo%2Fgo-string%2F</url>
    <content type="text"><![CDATA[1 概述 2 常规操作 len()，字符串占用的字节数 +，字符串连接 ==, &gt;, &lt; strings.Compare(a, b string) int strings.Contains(s, substr string) bool strings.ContainsAny(s, chars string) bool strings.ContainsRune(s string, r rune) bool strings.Count(s, substr string) int strings.EqualFold(s, t string) bool strings.Fields(s string) []string strings.FieldsFunc(s string, f func(rune) bool) []string strings.HasPrefix(s, prefix string) bool strings.HasSuffix(s, suffix string) bool strings.Index(s, substr string) int strings.IndexAny(s, chars string) int strings.IndexByte(s string, c byte) int strings.IndexFunc(s string, f func(rune) bool) int strings.IndexRune(s string, r rune) int strings.Join(a []string, sep string) string strings.LastIndex(s, substr string) int strings.LastIndexAny(s, chars string) int strings.LastIndexByte(s string, c byte) int strings.LastIndexFunc(s string, f func(rune) bool) int strings.Map(mapping func(rune) rune, s string) string strings.Repeat(s string, count int) string strings.Replace(s, old, new string, n int) string strings.Split(s, sep string) []string strings.SplitAfter(s, sep string) []string strings.SplitAfterN(s, sep string, n int) []string strings.SplitN(s, sep string, n int) []string strings.Title(s string) string strings.ToLower(s string) string strings.ToLowerSpecial(c unicode.SpecialCase, s string) string strings.ToTitle(s string) string strings.ToTitleSpecial(c unicode.SpecialCase, s string) string strings.ToUpper(s string) string strings.ToUpperSpecial(c unicode.SpecialCase, s string) string strings.Trim(s string, cutset string) string strings.TrimFunc(s string, f func(rune) bool) string strings.TrimLeft(s string, cutset string) string strings.TrimLeftFunc(s string, f func(rune) bool) string strings.TrimPrefix(s, prefix string) string strings.TrimRight(s string, cutset string) string strings.TrimRightFunc(s string, f func(rune) bool) string strings.TrimSpace(s string) string strings.TrimSuffix(s, suffix string) string 3 操作补充 3 顶层存储结构 1 概述字符串，string，一串固定长度的字符连接起来的字符集合。Go语言的字符串是使用UTF-8编码的。UTF-8是Unicode的实现方式之一。 Go语言原生支持字符串。使用双引号(“”)或反引号(``)定义。双引号：””, 用于单行字符串。反引号：``，用于定义多行字符串，内部会原样解析。示例：123456789// 单行&quot;心有猛虎，细嗅蔷薇&quot;// 多行`大风歌大风起兮云飞扬。威加海内兮归故乡。安得猛士兮守四方！` 字符串支持转义字符，列表如下： \r 回车符（返回行首） \n 换行符（直接跳到下一行的同列位置） \t 制表符 \’ 单引号 \” 双引号 \\ 反斜杠 \uXXXX Unicode字符码值转义，例如 &quot;\u5eb7&quot; 就是 “康” 2 常规操作len()，字符串占用的字节数utf-8 是变长字符集，英文标点占用1个字节，中文占用3个字节。1len(&quot;Hank康&quot;) // 7 +，字符串连接==, &gt;, &lt;strings.Compare(a, b string) intstrings.Contains(s, substr string) boolstrings.ContainsAny(s, chars string) boolstrings.ContainsRune(s string, r rune) boolstrings.Count(s, substr string) intstrings.EqualFold(s, t string) boolstrings.Fields(s string) []stringstrings.FieldsFunc(s string, f func(rune) bool) []stringstrings.HasPrefix(s, prefix string) boolstrings.HasSuffix(s, suffix string) boolstrings.Index(s, substr string) intstrings.IndexAny(s, chars string) intstrings.IndexByte(s string, c byte) intstrings.IndexFunc(s string, f func(rune) bool) intstrings.IndexRune(s string, r rune) intstrings.Join(a []string, sep string) stringstrings.LastIndex(s, substr string) intstrings.LastIndexAny(s, chars string) intstrings.LastIndexByte(s string, c byte) intstrings.LastIndexFunc(s string, f func(rune) bool) intstrings.Map(mapping func(rune) rune, s string) stringstrings.Repeat(s string, count int) stringstrings.Replace(s, old, new string, n int) stringstrings.Split(s, sep string) []stringstrings.SplitAfter(s, sep string) []stringstrings.SplitAfterN(s, sep string, n int) []stringstrings.SplitN(s, sep string, n int) []stringstrings.Title(s string) stringstrings.ToLower(s string) stringstrings.ToLowerSpecial(c unicode.SpecialCase, s string) stringstrings.ToTitle(s string) stringstrings.ToTitleSpecial(c unicode.SpecialCase, s string) stringstrings.ToUpper(s string) stringstrings.ToUpperSpecial(c unicode.SpecialCase, s string) stringstrings.Trim(s string, cutset string) stringstrings.TrimFunc(s string, f func(rune) bool) stringstrings.TrimLeft(s string, cutset string) stringstrings.TrimLeftFunc(s string, f func(rune) bool) stringstrings.TrimPrefix(s, prefix string) stringstrings.TrimRight(s string, cutset string) stringstrings.TrimRightFunc(s string, f func(rune) bool) stringstrings.TrimSpace(s string) stringstrings.TrimSuffix(s, suffix string) string3 操作补充3 顶层存储结构type Builder func (b Builder) Grow(n int) func (b Builder) Len() int func (b Builder) Reset() func (b Builder) String() string func (b Builder) Write(p []byte) (int, error) func (b Builder) WriteByte(c byte) error func (b Builder) WriteRune(r rune) (int, error) func (b Builder) WriteString(s string) (int, error)type Reader func NewReader(s string) Reader func (r Reader) Len() int func (r Reader) Read(b []byte) (n int, err error) func (r Reader) ReadAt(b []byte, off int64) (n int, err error) func (r Reader) ReadByte() (byte, error) func (r Reader) ReadRune() (ch rune, size int, err error) func (r Reader) Reset(s string) func (r Reader) Seek(offset int64, whence int) (int64, error) func (r Reader) Size() int64 func (r Reader) UnreadByte() error func (r Reader) UnreadRune() error func (r Reader) WriteTo(w io.Writer) (n int64, err error)type Replacer func NewReplacer(oldnew …string) Replacer func (r Replacer) Replace(s string) string func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)Bugs]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的函数]]></title>
    <url>%2Fgo%2Fgo-function%2F</url>
    <content type="text"><![CDATA[1 概述函数，function，独立的，用于实现具体功能的代码块。主要目的，是代码的重用（重复使用），更好的管理代码，模块化开发。函数通常使用参数和返回值，与调用者交互数据。参数给函数传递数据，返回值，函数将处理好的数据传递给调用者。Go语言中函数被称为一等公民（first-class）。意味着支持高阶函数，支持匿名函数，支持闭包等特性，可以满足接口等高级函数特性。 2 定义语法：123456定义：func 函数名(形参列表)(返回值类型列表) &#123; 函数体，通常会有return语句，返回值&#125;调用：函数名(实参列表) 函数名：函数的标识符，用于找到函数，内部是一个指向函数代码的地址。形参列表：由变量和类型构成返回值类型列表：函数返回值的类型，多个返回值需要指定多个。函数体：实现函数功能的具体语句。return语句：返回值语句 以上定的为命名函数，不能定义在其他函数内部。 3 参数用于在调用函数时向函数传递数据。实参，实际参数。调用时给的参数。指的是具有的特定实际数据的参数。形参，形式参数。定义时使用的参数。指的是用来表示函数需要参数，而定义时参数是没有任实际何数据的。当调用时会发生使用实参为形参变量赋值的过程，称为参数的传递。在函数的执行期间，形参是有具体数据的，形参当于函数内声明的变量。 参数的传递，分为值传递，地址传递两种方式。地址传递时，需要形参定义为指针类型，调用时需要取得地址传参。示例代码：1234567891011121314151617func funcTest(p1 int, p2 *int) &#123; p1++ *p2++ fmt.Println(p1, *p2)&#125;func main() &#123; var ( a1 = 42 a2 = 42 ) funcTest(a1, &amp;a2) // 参数赋值过程 fmt.Println(a1, a2)&#125;以上会输出43 4342 43 值传递，函数会得到实参的一份拷贝。地址传递，函数会得到实参地址，这样函数内通过地址对变量的修改，同时影响实参。 Go支持rest…不定数量参数，定义时将不定数量形参放在形参列表的最后定义，使用 …Type的方式，演示：123456定义：func funcTest(op string, nums ...int) &#123; fmt.Println(nums) // [4, 1, 55, 12], slice切片型数据&#125;调用funcTest(&quot;someOp&quot;, 4, 1, 55, 12) 接收到的参数为slice切片类型。 4 返回值return语句用于生成返回值。需要在函数定义时确定返回值类型，支持多值返回。演示语法：123func funcTest() (int, string) &#123; return 42, &quot;Hank&quot;&#125; 可以在定义时，声明返回的变量。这个做法叫命名返回，演示为：12345func funcTest() (num int, title string) &#123; num = 42 title = &quot;Hank&quot; return&#125; 不用return任何数据，直接return即可！ 5 函数变量函数可以看作一种特殊的指针类型，可以和其他类型一样被保存在变量中。通过函数标识符和变量都可以访问到该函数，演示如下：123456789101112131415func funcTest() &#123; fmt.Println(&quot;func() type&quot;)&#125;func main() &#123; fmt.Printf(&quot;%T, (%v)\n&quot;, funcTest, funcTest) fn := funcTest fmt.Printf(&quot;%T, (%v)\n&quot;, fn, fn) funcTest() fn()&#125;执行结果：func(), (0x48fe20)func(), (0x48fe20)func() typefunc() type 可见，函数标识符就是指向函数的指针。可以赋值给其他变量。 6 函数参数函数也可以作为其他函数的参数来使用，演示如下：12345678func funcSuccess() &#123;&#125;func funcAsync(handle func()) &#123; // 调用函数参数 handle()&#125;// 传递函数到其他函数funcAsync(success) 这种回调函数的使用语法，在处理异步逻辑时十分有用。 7 匿名函数可以定义匿名函数。可以将匿名函数保存到变量中，作为参数传递，或者立即调用。如果函数时临时使用函数，则匿名函数是一个好选择。示例语法：123456789101112赋值给变量fn := func() &#123;&#125;fn()// 作为参数someFunc(func() &#123; &#125;)// 立即调用func() &#123; &#125;() 8 闭包由于匿名函数可以定义在其他函数内，同时变量的作用域为层叠的，也就是匿名函数可以会访问其所在的外层函数内的局部变量。当外层函数运行结束后，匿名函数会与其使用的外部函数的局部变量形成闭包。示例代码：1234567891011var fn func()func outer() &#123; v := 42 fn = func() &#123; v ++ fmt.Print(v) &#125;&#125;outer()fn() // 43 此例中，fn 对应的匿名函数与 outer() 的局部变量 v，就形成了闭包。 9 函数调用示意图123456789var v = &quot;global&quot;func funcTest(v) &#123; v = &quot;funcTest&quot; fmt.Println(v)&#125;func main() &#123; v := &quot;main&quot; funcTest(v)&#125; 代码编译期间，会将函数代码存放在内存代码区。函数被调用时，在运行期间会在函数运行栈区开辟函数栈，内部由局部变量标识符列表（就是局部变量），上层标识符列表引用等信息。直到运行结束，此空间才会被出栈，释放。函数内部调用了新函数，新函数的执行空间入栈，要等到新函数执行空间出栈，调用他的函数才会被出栈。以上代码的运行逻辑图如下： 10 递归调用函数内部调用函数本身。称之为递归调用。示例代码：1234func funcTest() &#123; fmt.Println(&quot;run&quot;) funcTest()&#125; 定义实现递归调用函数时，通常需要定义一个出口。用来确定何时不再进行递归调用了。一旦满足条件，则调用停止。例如：1234567func funcTest(v) &#123; fmt.Println(v, &quot;run&quot;) v ++ if v &lt;= 10 &#123; funcTest() &#125;&#125; 典型的应用有，树状菜单的处理，遍历目录，快速排序等。递归调用的优势是编码简单，与描述的业务逻辑保持一致。 完！]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的流程控制]]></title>
    <url>%2Fgo%2Fgo-flow-control%2F</url>
    <content type="text"><![CDATA[1 概述 2 条件分支 if 3 状态分支 switch 3.1 基础 3.2 fallthrough，向下穿越 3.3 条件型 switch 4 循环for 4.1 基本 4.2 省略语句 4.3 break 4.4 continue 4.5 嵌套循环 5 goto 6 延迟执行defer 1 概述Go语言提供了条件分支 if，状态分支 switch，循环 for，跳转 goto，延迟执行 defer，这些流程控制语句。分别作说明如下： 2 条件分支 if依据条件是否满足确定执行哪个分支。语法：123456789if 条件 1 &#123; 分支 1&#125; else if 条件 2 &#123; 分支 2&#125; else if 条件 ... &#123; 分支 ...&#125; else &#123; 分支 else&#125; 流程图： Go是强类型，要求条件表达式严格返回布尔型数据！ 3 状态分支 switch3.1 基础状态分支，依据特定的状态值进行分支判断。语法：12345678910switch 分支测试表达式 &#123;case 状态1: 分支1case 状态2: 分支2case 状态...: 分支...default: 分支 default&#125; 流程如下： 3.2 fallthrough，向下穿越在其他语法（非Go，C，PHP）中，switch 有一个特定的现象，就是向下穿越，指的是一旦一个分支 case 满足，则后续分支代码都会被执行。而Go语言中，默认分支执行完毕，switch 执行完毕。使用 fallthrough 语法，可以达到穿越下一个 case 分支的目的。fallthrough 需要出现在分支语句块的最后一句！语法：12345678910switch 分支测试表达式 &#123;case 状态1: 分支1 fallthroughcase 状态2: 分支2 fallthroughdefault: 分支 default&#125; 流程如下： 3.3 条件型 switch示例代码，逻辑与 if-else-if 一致：123456789score := 89switch &#123;case score &gt;= 90: fmt.Println(&quot;优秀，不错&quot;)case score &gt;= 80: fmt.Println(&quot;还行吧&quot;)default: fmt.Println(&quot;呵呵&quot;)&#125; 个人感觉失去了 switch 分支的意义哈！ 4 循环for4.1 基本语法格式：12345678for 初始化语句; 条件语句; 条件变化语句 &#123; 循环体&#125;// 输出1-10for i := 1; i &lt;= 10; i++ &#123; fmt.Println(i)&#125; 流程如下： 4.2 省略语句Go中允许省略三个语句中的任意，就是可以形成如下的语法：仅存在条件语句，类似其他语言的 while 结构！123for 条件语句 &#123; 循环体&#125; 无限循环结构，死循环123for &#123; 循环体&#125; 其他结构，三个语句可以任意省略，不再列举：123456for ; 条件语句; 条件变化语句 &#123; 循环体&#125;for 初始化语句; 条件语句; &#123; 循环体&#125; 4.3 break终止整个循环执行。流程图如下： 4.4 continue终止本次循环体的继续执行，进行循环条件变化。流程如下： 4.5 嵌套循环语法：12345for &#123; for &#123; &#125;&#125; 在使用 break，continue 时，若需要终止外层循环 for，需要配合语句标签使用，演示如下：12345678userLabel:for &#123; for &#123; break userLabel 或者 continue userLabel &#125;&#125; 额外注意，switch 在语言中，被视为执行一次的循环结构，因此 switch 中若要终止外层循环，需要使用标签语法，不能直接 break、continue，演示如下：123456789userLabel:for &#123; swtich variable &#123; case &quot;exit&quot; break userLabel 或者 continue userLabel &#125;&#125; 5 goto配合标签完成无条件跳转。演示如下：12345678if error &#123; goto doError&#125;// 其他业务逻辑代码略doError:fmt.Println(errorInfo) 6 延迟执行deferdefer 语句会将其后语句进行延迟处理。在 defer 所属函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。演示如下：12345678910111213 func main() &#123; fmt.Println(&quot;before defer&quot;) defer fmt.Println(&quot;defer A&quot;) defer fmt.Println(&quot;defer B&quot;) defer fmt.Println(&quot;defer C&quot;) fmt.Println(&quot;after defer&quot;)&#125;以上代码的执行结果：before deferafter deferdefer Cdefer Bdefer A defer 执行是放在一个临时的调用栈中，因此是先入栈后出栈的。流程图如下： 实操时，处理互斥所时，很常用！ 以上就是Go语言提供的流程控制相关内容完！]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的运算符]]></title>
    <url>%2Fgo%2Fgo-operator%2F</url>
    <content type="text"><![CDATA[1 概述 2 算术运算 3 字符串连接运算 + 4 关系运算 5 逻辑运算 6 指针运算 7 位运算 8 赋值运算 9 运算符优先级 10 类型转换 1 概述Go语言提供了，算术，关系，逻辑，位，指针，赋值运算符。本篇整体说明一下。 2 算术运算 + 相加 - 相减 * 相乘 / 相除 % 求余 ++ 自增 -- 自减 几个细节，需要留意一下。 整数与浮点数进行运算，会将整数转化为浮点数，再运算。 两个整数相除，结果是整数，取整数部分。5/3 结果会是 1。 求余，如果被除数或除数存在负数，那么余数与被除数保持一致。此处是求余不是取模。 ++/–，不区分前后，只有变量后的语法，就是 v++。同时++/–构成语句而不是表达式，意味着不能直接赋值。 3 字符串连接运算 ++运算符，也可以完成字符串的连接运算。1&quot;Hello&quot; + &quot; &quot; + &quot;Hank!&quot; 4 关系运算 == 检查两个值是否相等 != 检查两个值是否不相等 > 检查左边值是否大于右边值 &lt; 检查左边值是否小于右边值 >= 检查左边值是否大于等于右边值 &lt;= 检查左边值是否小于等于右边值 关系运算时用于判断两个运算数的关系是否成立。返回布尔值。 5 逻辑运算 &amp;&amp; 逻辑与，参与运算的两个关系必须同时成立，结果为true，否则为false || 逻辑或，参与运算的两个关系成立一个（或都成立）结果为true，全部关系为false，结果为false。 ! 逻辑非，用于取反某个关系。非真既假，非假既真。只有一个运算数参与运算 用来判断多个关系是否成立。运算结果为：&amp;&amp;true &amp;&amp; true = truetrue &amp;&amp; false = falsefalse &amp;&amp; true = falsefalse &amp;&amp; false = false||true || true = truetrue || false = truefalse || true = truefalse || false = false!!true = false!false = true 6 指针运算 &amp; 取得变量的内存地址。pv := &amp;v * 获取指针地址对应的值。*pv示例为：123456v:=42pv:=&amp;vfmt.Printf(&quot;%T(%v)&quot;, pv, pv)// *int 0xc000048b68，*int就是指针类型 值为一个类似规则的地址，就是一个号码，标识内存的一个空间区域fmt.Println(*pv)// 42，通过地址获取对应的变量值*pv ++ // 通过地址更改对应变量fmt.Println(*pv, v)// 42 42变量和指针操作的同一变量（内存地址）。 Go语言的指针不可以操作。不能执行偏移这类的操作. 理解指针的几个概念：变量：标识符与值（内存中存储空间）引用。地址：内存中存储空间的位置（门牌号）指针：一种类型，其值为某个地址。 一个数据（变量），我们可以通过变量标识符找到他。也可以将他的地址记录下来，通过这个地址找到他。能够记录地址的数据类型就是指针。指针通过&amp;运算符来获取变量的地址。 7 位运算 &amp; 按位与运算 | 按位或运算 ^ 按位异或运算 &lt;&lt; 左移运算符，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。左移n位就是乘以2的n次方。 >&gt; 右移运算符，”&gt;&gt;”右边的数指定移动的位数，低位舍弃，高位补0。右移n位就是除以2的n次方。 用于运算构成整数的每个二进制位，就是位上0，1的运算。 8 赋值运算 = 简单的赋值运算符，将一个表达式的值赋给一个左值 += 相加后再赋值 -= 相减后再赋值 *= 相乘后再赋值 /= 相除后再赋值 %= 求余后再赋值 &lt;&lt;= 左移后赋值 >&gt;= 右移后赋值 &amp;= 按位与后赋值 ^= 按位异或后赋值 |= 按位或后赋值 变量 = 表达式=左边的变量，称之为左值。通常只能是变量。=右边的表达式，称之为右值。表达式是右值。 自赋值运算，一些运算符，可以与赋值运算符结合，完成快捷自运算赋值，就是上面的+=….|=，逻辑是：v += 1 相当于 v = v + 1其他的逻辑相同！ 9 运算符优先级由高到低，列表如下： ^ ! * / % &lt;&lt; &gt;&gt; &amp; &amp;^ + - | ^ == != &lt; &lt;= &gt;= &gt; &lt;- &amp;&amp; || 建议使用()小括号，明确调整优先级。 10 类型转换类型不同的数据不能完成运算。如果需要，则要将类型转换为一致的类型。自动转换，有些转换Go语言自动完成，例如 5/4.0 5整型会被自动转换为浮点数。强制转换，使用语法 type(数据) 的形式转换，例如：float64(5)。 Go语言对类型要求比较严格，类型可以相互转换的场景不多，主要集中在数值上。就是要类型兼容，才可以转换。 完！]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言的数据类型]]></title>
    <url>%2Fgo%2Fgo-type%2F</url>
    <content type="text"><![CDATA[1 概述 2 整数，int 3 浮点数，float 4 复数，complex32,complex64 5 字符，byte，rune 6 字符串，string 7 布尔型，bool 8 指针，pointer 9 数组，array 10 nil 11 切片，slice 12 映射，map 13 结构体，struct 14 接口，interface 15 函数，func() 1 概述Go语言作为类C语言，支持常规的基础数据类型的的同时，支持常用的高级数据类型。他们是： 整数，int，uint，int8，uint8，int16，uint16，int32，uint32，int64，uint64 浮点（小数），float32，float64 复数，complex 字符，byte，rune 字符串，string 布尔，bool 指针，pointor 数组，array nil 切片，slice。（引用类型） 映射，map 结构体，struct 接口，interface 函数，func() 本篇相当于一个类型索引。包含了Go语言中的全部类型。具体每种类型的操作，请参见具体章节！ 2 整数，int支持的整型分类很细，主要差异是占用的存储空间不同。基于有无符号列出为：有符号的：int，int8，int16，int32，int64无符号的：uint，uint8，uint16，uint32，uint64 其中int, unit是基于处理器架构的。意味着会根据处理器来确定是32bit还是64bit。使用时，常常使用int。或者使用int32保证兼容。在类型推导时，推导的整型为int，其他长度整型需要在定义变量时强制声明。示例：123421024-36 整型的默认值为0。 3 浮点数，float支持IEEE-754标准浮点数。支持32bit和64bit的浮点数float32和float64。在类型推导时，推导的浮点型为float64。float32需要在定义变量时强制声明。示例：12341.03.140.6184.2E10 // 4.2*10^10 浮点数的默认值为0。 4 复数，complex32,complex64原生支持复数。支持32bit+32bit复数complex64，和64bit+64bit的复数complex128。 5 字符，byte，rune使用单引号定义字符型数据，字符指的是单个字符。有两种byte和rune：byte：单字节字符，是uint8的别名。用于存储ASCII字符集字符rune：多字节字符，是int32的别名。用于存储unicode字符集字符。在类型推导时，推导的字符型为rune。byte需要在定义变量时强制声明。示例：12&apos;c&apos;&apos;康&apos; 字符的默认值是0。字符的本质就是整数型，根据字符集得到对应的字符。 6 字符串，string原生支持字符串。使用双引号(“”)或反引号(``)定义，内部是utf-8编码。双引号：””, 用于单行字符串。反引号：``，用于定义多行字符串，内部会原样解析。示例：123456789// 单行&quot;心有猛虎，细嗅蔷薇&quot;// 多行`大风歌大风起兮云飞扬。威加海内兮归故乡。安得猛士兮守四方！` 字符串支持转义字符，列表如下： \r 回车符（返回行首） \n 换行符（直接跳到下一行的同列位置） \t 制表符 \’ 单引号 \” 双引号 \\ 反斜杠 \uXXXX Unicode字符码值转义 7 布尔型，bool布尔型的值只可以是常量 true 或者 false。示例：123var ( isFinished = false ) 8 指针，pointer指针类型用于存储变量地址。使用运算符 &amp; , *完成操作。使用运算符 p:=&amp;v 可以获取v变量的地址。p中的数据格式类似0xc0000b9528，是一个内存地址的16进制表示。使用运算符 *p 可以获取指针p指向变量v的值。如图所示： 在Go语言中，指针主要用于： 类型指针，对指针指向的数据进行修改。函数调用时传递参数使用指针，避免值传递拷贝额外数据。注意类型指针不能进行偏移和运算。 切片，由指向起始元素的原始指针、元素数量和容量组成。示例：1234p := 42pv := &amp;p*pv ++// p == 43 9 数组，array数组是一段固定长度的连续内存区域。是具有相同类型数据元素序列。元素类型支持任意内置类型。数组从声明时就确定长度，可以修改数组元素，但是数组不可修改长度。使用 [长度]类型 进行数组的声明。示例：123456// 默认值初始化var nums [4]int // [0 0 0 0]// 指定初始值var position = [4]string&#123;&quot;east&quot;, &quot;south&quot;, &quot;west&quot;, &quot;north&quot;&#125;// 自动确定长度var position = [...]string&#123;&quot;east&quot;, &quot;south&quot;, &quot;west&quot;, &quot;north&quot;&#125; 会使用类型默认值初始化元素。数组不是引用类型，变量间为值传递。 可以使用range配合循环结构完成遍历，示例如下：12345678for k, v := range position &#123; fmt.Println(k, v)&#125;// 结果0 east1 south2 west3 north 10 nilnil，可以理解为未初始化引用。是以下类型的默认初始值： pointers -&gt; nil slices -&gt; nil maps -&gt; nil channels -&gt; nil functions -&gt; nil interfaces -&gt; nil 11 切片，slice切片是一个拥有相同类型元素的可变长度的序列。与数组的固定长度不同，切片也被称之为动态数组。Go提供了4中方案定义切片：1234make ( []Type ,length, capacity )make ( []Type, length)[]Type&#123;&#125;[]Type&#123;value1 , value2 , ... , valueN &#125; 或者从数组或切片生成新切片：slice [开始索引:结束索引] slice 表示目标切片对象。 开始索引和结束索引对应目标切片的索引。 不包含结束索引对应的元素 缺省开始索引，表示从头到结束索引。 缺省结束索引，表示从开始索引到末尾。 两者同时缺省时，全部切取，与切片本身等效。 两者同时为0时，等效于空切片，一般用于切片复位。12var arr = [4]string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;var sli = arr[1:3] // [&quot;b&quot;, &quot;c&quot;] 以从数组创建切片为例，理解切片，定义语法如上所示，下图为slice: 切片的实现是由一个底层数组以及其上面的动态位置，尺寸来实现。由内部由指向起始元素的指针、元素数量length和容量capacity组成。其中： 指针ptr，用于指向切片在底层数组的起始位置。 尺寸len，用于记录切片内元素数量。 容量cap，当前切片最大容量，也就是底层数组的容量。可以动态分配。 切片为引用类型。切片的默认初始值为nil。切片支持: len()尺寸, cap()容量, append()追加元素等操作。详见切片的使用。 12 映射，mapGo语言中的键值对(key-&gt;value)集合，称之为映射map。创建语法：var m = map[key_type]value_type{key1: value1, key2: value2}var m = make(map[key_type]value_type)示例,字符串型下标，字符串型值：12345678var m = make(map[string]string) //make()会分配内存空间，初始化。m[&quot;east&quot;] = &quot;东&quot;m[&quot;west&quot;] = &quot;西&quot;fmt.Println(m[&quot;east&quot;]) // 东fmt.Println(m[&quot;west&quot;]) // 西// map演示var m = map[string]string&#123;&quot;east&quot;: &quot;东&quot;, &quot;west&quot;: &quot;西&quot;&#125; 支持遍历操作，使用range：123for k, v := range mapVar &#123; fmt.Println(k, v)&#125; 映射是引用类型。详见切片操作。 13 结构体，structGo语言使用结构体来描述现实业务逻辑中实体。是自定义类型。结构体是由一系列数据构成的数据集合，一系列数据类型可以不同。定义结构体，使用struct关键字：type 结构体名 struct { 成员1 类型 成员2 类型 …}示例：12345678910111213141516171819202122232425262728293031323334// 定义Product结构type Product struct &#123; // 两个成员 name string price float64&#125;// 构造函数func newProduct(name string, price float64) *Product &#123; return &amp;Product&#123;name, price&#125;&#125;// 成员方法，接收器方式func (p *Product) getName() string &#123; return &quot;《&quot; + p.name + &quot;》&quot;&#125;// 方法2func (p *Product) setPrice(price float64) *Product &#123; p.price = price return p&#125;func main() &#123; // 构造Product型数据p1 var p1 = newProduct(&quot;BlockChain&quot;, 42.5) // 访问成员 fmt.Println(p1.name) // 通过接收器访问方法 fmt.Println(p1.getName()) var p2 = newProduct(&quot;GoLang&quot;, 30.5) p2.setPrice(44.5) fmt.Println(p2.price)&#125; 详见结构体操作。 14 接口，interface接口是一种协议，用来规范方法的调用和定义的协议，目的是保证设计的一致性，便于模块化开发以及通讯。Go语言中，也视为一种类型。定义语法：type 接口名 interface { 方法1( 参数列表 ) 返回值类型列表 方法2( 参数列表 ) 返回值类型列表 …}可以理解成没有方法体的方法。示例：1234567891011121314151617181920212223242526272829303132333435363738// 定义Product结构type Product struct &#123; // 两个成员 name string price float64 // say func()&#125;// 构造函数func newProduct(name string, price float64) *Product &#123; return &amp;Product&#123;name, price&#125;&#125;// 成员方法，接收器方式func (p *Product) getName() string &#123; return &quot;《&quot; + p.name + &quot;》&quot;&#125;// 方法2func (p *Product) setPrice(price float64) *Product &#123; p.price = price return p&#125;// 定义接口type ProductInterface interface &#123; getName() string setPrice(price float64) *Product&#125;func main() &#123; // 构造Product型数据p1 var p1 = newProduct(&quot;BlockChain&quot;, 42.5) // pi为接口，为其赋值p1，就意味着使用接口规范p1，若p1不满足接口定义则出错 var pi ProductInterface = p1 // 利用接口调用方法 fmt.Println(pi.getName())&#125; 详见接口操作 15 函数，func()Go语言中，函数可以作为数据存储变量中，此时变量为函数类型func()。可以通过该变量访问到这个函数。可以用在结构体成员定义上。语法示例：123456789101112131415func sayHello(name string) &#123; fmt.Println(&quot;Hello, &quot;, name)&#125;func main() &#123; // 函数本身就是函数类型 fmt.Printf(&quot;%T(%v)\n&quot;, sayHello, sayHello) // func(string)(0x48fe20) // 赋值给变量 var f = sayHello fmt.Printf(&quot;%T(%v)\n&quot;, f, f) // func(string)(0x48fe20) // 匿名函数也是函数类型 var af = func() &#123; &#125; fmt.Printf(&quot;%T(%v)\n&quot;, af, af) // func()(0x490080)&#125; 参见函数使用]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的变量]]></title>
    <url>%2Fgo%2Fgo-variable%2F</url>
    <content type="text"><![CDATA[1 概述 2 定义：声明和初始化 3 类型默认值（零值） 4 强类型 5 类型推导 6 短声明（定义） 7 批量定义 8 批量赋值 9 匿名变量 10 变量作用域 1 概述变量（Variable）是程序运行过程中，内容可以变化（修改）的量，变量的功能是存储用户的数据，是计算机语言中能储存计算结果或能表示值抽象概念。变量，是通过变量的标识符定位值的过程。变量的内存模拟演示： 2 定义：声明和初始化定义变使用var关键字，需要指定其类型，可以同时初始化，如果没有指定初始化值，则使用类型的默认值，语法如下：1234// 声明变量，未初始化（默认值初始化）var name string// 声明变量，特定值初始化var user string = &quot;Hank&quot; Go语言中的变量必须声明后才可以使用，不能直接使用未定义的变量。 3 类型默认值（零值）Go语言的类型默认值如下所示： 整型和浮点型变量的默认值为 0。 字符串变量的默认值为空字符串。 布尔型变量默认为 bool。 切片、函数、指针变量的默认为 nil。 4 强类型Go语言是强类型语言，变量必须有类型，同时变量仅仅可以存储特定类型的数据。 5 类型推导定义变量时，如果指定了初始值，则可以省略类型的定义，Go语言可以自己由数据推导出类型。语法为：12// 声明变量，特定值初始化，类型推导出user为字符串string型var user = &quot;Hank&quot; 6 短声明（定义）为了简化定义变量，使用运算符 := 配合类型推导，可以快速完成变量的定义，语法为：1user := &quot;hank&quot; 7 批量定义使用var或:=都可以一次性定义多个变量，语法为：var123456var ( v1 = 42 v2 = &quot;hank&quot; )也可以var v1, v2 = 42, &quot;hank&quot; :=1v1, v2 := 42, &quot;hank&quot; 推荐使用 var() 声明块语法，因为代码维护容易。 8 批量赋值一次性为多个变量进行赋值。（类似短定义。v1, v2, v3 := 42, “hank”, false）当变量定义完毕后，再批量对其赋值，没有定义功能！语法为：123456var ( v1 int v2 int)// 批量赋值v1, v2 = 42, 1024 该语法，通常配合函数的批量返回来使用，一次性接收多个返回值，语法为：12345678910111213func main() &#123; var ( v1 int v2 int ) // 调用函数，接收其返回值 v1, v2 = getData()&#125;// 返回两个值的函数func getData() (int, int) &#123; // 返回了两个值（假设42为最小值，1024为最大值） return 42, 1024&#125; 非常方便的可以交换两个变量的值：123456var ( v1 = 42 v2 = 1024)// 交换v1, v2 = v2, v1 执行后，v1==1024, v2==42 9 匿名变量标识符为（下划线）的变量，是系统保留的匿名变量，在赋值后，会被立即释放，称之为匿名变量。其作用是变量占位符，对其变量赋值结构。通常会在批量赋值时使用。例如，函数返回多个值，我们仅仅需要其中部分，则不需要的使用来占位，演示：123456789101112func main() &#123; var ( v int ) // 调用函数，仅仅需要第二个返回值，第一，三使用匿名变量占位 _, v, _ = getData()&#125;// 返回两个值的函数func getData() (int, int, int) &#123; // 返回3个值 return 42, 1024, 2012&#125; 10 变量作用域Go语言中的变量是块作用域。块，指的是使用{}定义的代码段，包括函数，if/switch/for语句，或独立的{}都是块。在块内定义的变量仅仅在本块内可用。定义，指的是 var 或者 := 定义的变量。Go语言的作用域是层叠的，就是说内层块可以直接访问到外层块的变量，前提是内层块没有定义同名的外层变量。演示如下：12345678910111213141516171819202122232425// 全局（函数外）定义3个变量var ( v1 = 1 v2 = 2 v3 = 3)func main() &#123; // main&#123;&#125;函数块，定义2个变量 var ( v2 = 22 v3 = 33 ) fmt.Println(v1, v2, v3) // 结果 1 22 33 &#123; // main()函数内部&#123;&#125;块，定义1个变量 var ( v3 = 333 ) fmt.Println(v1, v2, v3) // 结果 1 22 333 &#125;&#125; 上面代码中：在main()中，v2，v3被重新定义，则在main()中，v1是外部，而v2, v3是main函数局部的。在main()内部的{}中，v3被重新定义，则在main()内部的{}中，v1是外部，而v2是main()定义的, v3是main()内部{}定义的的。 变量可以沿内部作用域向外部作用域查找变量的过程。 带有{}的语句，其中的变量也仅仅在内部有效，例如for，if，switch等，演示：12345for i := 0; i &lt; 10; i++ &#123; fmt.Println(i)&#125;fmt.Println(i)// 会提示变量i未定义, undefined: i 注意i，是通过短声明在for内部定义的变量，仅仅在for内部有意义。 互不嵌套的{}见作用域不可见，不可互相访问。123456789func main() &#123; &#123; v := 42 &#125; &#123; fmt.Println(v) // 会提示变量v未定义, undefined: v &#125;&#125; 一家之言，欢迎讨论！]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的常量]]></title>
    <url>%2Fgo%2Fgo-constant%2F</url>
    <content type="text"><![CDATA[1 概述 2 定义单个常量 3 类型推导 4 定义多个常量 5 iota迭代定义常量 6 常量在编译时确定 7 常量的作用 1 概述常量，一经定义不可更改的量。功能角度看，当出现不需要被更改的数据时，应该使用常量进行存储，例如圆周率。从语法的角度看，使用常量可以保证数据，在整个运行期间内，不会被更改。例如当前处理器的架构类型，可以保证不被更改。 语法如下 2 定义单个常量const 常量名 &lt;可选的类型&gt; = 常量值1const c1 int = 1000 Go语言中，标识符（常量名）是否大小写，取决于是否需要在导出时被识别。 常量的值仅仅支持，基础类型，字符串，字符，整型，浮点，布尔。 3 类型推导类型可以通过值推导出来，大多数情况可以省略类型，例如1const c2 = 1000 除非你想使用例如，int8, byte，float32这些非默认类型时，需要指定类型，例如1const c3 int16 = 1000 4 定义多个常量可以一行定义多个常量，例如：1const c4, c5 = 42, 1000 也可以使用 const()定义块，定义多个，每个常量单独一行，例如1234const ( c6 = 42 c7 = 1000) 推荐使用const()块语法，一次性定义多个。 const()块定义时，如果常量未给出定义，则延续上面的定义规则，例如：12345const ( c7 = 42 c8 // c8 = 42 c9 // c9 = 42) 此时，c8, c9, 值都是42。 5 iota迭代定义常量const配合iota关键字使用，可以定义一组由0开始+1迭代的常量演示语法：12345const ( gender_secret = iota gender_male // = iota gender_female // = iota) 此时，三个常量值，分别是,0, 1, 2iota的规则是：若iota出现在const()中，那么const()定义的第一行的iota就是0，第二行就是0+1=1，不论iota是否被常量使用。演示如下：12345678const ( c1 = 42 // iota = 0，虽然未使用iota，但后边（const()中）有使用，此时iota被初始化为0，下面每行累加1 c2 = iota // iota = 1，iota继续累加，使用了iota c3 = 1024 // iota = 2，同样未使用，但iota的值继续累加。c3 被定义为1024 c4 // iota = 3，c4延续上面的定义c4=1024，iota继续累加 c5 = iota // iota = 4，iota继续累加，使用了iota c6 = iota // iota = 5，iota继续累加，使用了iota) 此时结果为：42, 1, 1024, 1024, 4, 5 6 常量在编译时确定编译时确定，因此不能使用变量为其赋值。可以使用，确定的字面量，字面量运算，内置函数运算，其他定义常量，这些在编译时可以确定的内容为常量赋值，演示为：123456const c1 = &quot;hank&quot;const ( c2 = c1 c3 = 42 + 1024 c4 = len(&quot;hank&quot;)) 以上语法都可以！ 7 常量的作用 将特殊的值，语义化。使用时，可以知道其具体含义。 数据的集中管理，更改常量定义，即可完成全部的修改。 保证不被程序的其他代码所更改。 一家之言，欢迎讨论！]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go-editor-sublime]]></title>
    <url>%2Funcategorized%2Fgo-editor-sublime%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[git中使用merge和rebase的区别]]></title>
    <url>%2Fgit%2Fgit-merge-rebase%2F</url>
    <content type="text"><![CDATA[1 需求今天和朋友讨论了一下 分支间的整合方案，merge和rebase。以及pull操作模式。下面整理如下： 2 git pull做了什么 git-pull - Fetch from and integrate with another repository or a local branch译：从另一个版本库或本地分支拉取并与其整合 文档如上说，可见pull（拉取）执行了两个操作，他们是fetch（获取）和integrate（整合）。拉取就是将版本从远程拉取到本地，可以理解成下载。而整合指的是将拉取的版本与本地版本合并到一起。这个合并的操作，通常会有两种模式来实现，就是merge和rebase。 3 git merge合并 git-merge - Join two or more development histories together译：将两个或多个开发历史合并一起 merge，合并模式。指的是合并两个分支，最终的合并代码形成一个新的版本，两个分支的版本日志按照时间顺序合并到一起即可。 演示如下，git merge dev： 合并过程是，git会自动根据两个分支的共同祖先即v2，与两个分支的最新提交即master的v6和dev的v5进行一个三方合并，然后将合并中更新的内容生成一个新的版本即v6，内容合并完成后，会成立版本日志并记录。 merge的好处是版本不会出现错乱的情况（一会可以对比rebase，你会发现有错乱的情况），但多了一个额外的版本。（其实无所谓啦）再看rebase模式。 4 git rebase变基 git-pull - Reapply commits on top of another base tip译：在另一个的基本上重新应用提交 rebase，重设基础。指的是整合时，以另一个为基础（dev），将当前的（master）应用上去。演示如下，git rebase dev： 合并过程为，git会从两个分支的共同祖先即v2开始提取当前分支即master上的提交版本即v4和v5，将提取的修改v4和v6依次应用到目标分支dev的最新提交的后面。将master指向最新的合并版本。 从合并结果上看，rebase导致版本变为了：v1-&gt;v2-&gt;v3-&gt;v5-&gt;v4-&gt;v6，与真实的版本提交时间不一致了，就是发生了错乱。但rebase不会生成新的版本。 5 merge VS rebase该如何选择他们？ 当某个分支不再需要了（例如一个本地的bug分支，修复完毕就不在需要了），那么我们选择merge是合理的。 当我们的项目重启了，代码依赖的基础发生升级了，那么我们就可以rebase到这个升级之后的基础上继续开发。 rebase -i，一个交互式的rebase，可以用来编辑版本信息，可以获得更加整洁的版本日志。 千万不要在主体分支上使用rebase，否则会导致历史胡乱的。 如果git pull的时候，出现 error: failed to push some refs to &#39;版本库&#39;， 可以git pull --rebase来解决下，后面说明原因。 这个还需要再总结一下。 6 结束有问题，欢迎留言讨论！]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客，发布到GitHub]]></title>
    <url>%2Fhexo%2Fhexo-github%2F</url>
    <content type="text"><![CDATA[1 需求博客之前是wordpress搭建的，也很好用。现在想使用一个基于markdown文件为中心的博客系统，就锁定了hexo这个项目。hexo是基于Node.js的，提供markdown支持，草稿，单页，分类，标签，主题，i18n，永久链接，静态生成，部署等很常用的博客系统功能。其主页地址为：Hexo，大家可以获取更详细的信息。下面就和大家说说过程，大致有博客搭建，部署到github，还有另一个git服务器（个人的服务器）上的过程。 下面的操作的个人电脑为windows系统（win10)。 2 hexo搭建博客此步骤完成后，可以在自己本地电脑上，看到完整的博客系统了。 2.1 快速开始在安装好 Node.js, Git的基础上，执行下面代码即可12345$ npm install -g hexo-cli$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install$ hexo server 浏览器访问http://localhost:4000，即可看到你的博客。 如果没有Node.js或Git，请按照下面的步骤执行。 2.2 安装Node.jsNode.js是基于Chrome V8 JavaScript引擎的JavaScript运行环境(runtime built)。安装方式请参考Node.js官网 ，或者本站的Node.js相关内容。安装完毕后，应出现如下效果，表示安装成功：1234C:\Users\Kang&gt; node -vv8.12.0PS C:\Users\Kang&gt; npm -v6.4.1 安装Node.js还可以使用nvm（Node Version Manager，Node.js的版本管理工具）。使用nvm可以方便的安装Node.js的各种版本，以及在版本间进行切换。安装使用方式请参考windows下的nvm和linux下的nvm或者本站的Node.js相关内容。 2.3 安装GitGit是开源免费的分布式版本控制系统是用来处理代码量由小到大相关问题的。安装方式请参考Git官网，或者本站的Git相关内容。安装完毕后，应出现如下效果，表示安装成功：12C:\Users\Kang&gt; git versiongit version 2.19.1.windows.1 2.4 安装Hexo使用npm按照hexo即可，运行如下代码全局按照hexo-cli这个hexo的命令行工具1$ npm install -g hexo-cli 安装完毕后，应出现如下效果，表示安装成功：1234567891011121314151617C:\Users\Kang&gt; hexo -vhexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 8.12.0v8: 6.2.414.66uv: 1.19.2zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.32.0napi: 3openssl: 1.0.2picu: 60.1unicode: 10.0cldr: 32.0tz: 2017c 2.5 Hexo建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 选择好需要的站点目录（目录地址不要有中文）。例如选择 D:\projects\practice\blog&gt; 作为建站目录，那么执行如下操作即可：12345C:\Users\Kang&gt; d:D:\&gt; cd .\projects\practiceD:\projects\practice&gt; hexo init blogD:\projects\practice&gt; cd blogD:\projects\practice\blog&gt; npm install 此时一个基本的博客已经建立完毕了。 2.6 运行Hexo博客进入博客目录，执行 hexo server 即可运行hexo服务器。123D:\projects\practice\blog&gt; hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 此时，浏览器访问http://localhost:4000，即可看到你的博客。效果如下： 至此，hexo搭建的博客已经完成。该博客使用方法，如何发文章，分类，标签等操作请参考Hexo文档，本文不再赘述。 3.发布到GitHubGitHub上允许我们搭建自己的静态站点，在不购买自己的服务器情况下，可以有自己的博客。需要用到Hexo提供的发布相关功能，同时需要在github上做一定的配置。 3.1 注册GitHub 已有账号的跳过此步骤 注册操作，跟着GitHub引导完成即可，GitHub注册 3.2 创建版本库登录后，创建新版本库https://github.com/new 注意：版本库名字强烈建议是 &lt;你的用户&gt;.github.io 这种格式创建完毕后，就可以使用 &lt;你的用户&gt;.github.io 这种方式访问你的github博客地址，但现在访问应该不会成功，因为是一个新创建的版本库，是空的，一无所有….。接下来就把我们本地的博客内容部署到这个github版本库上。 3.3 GitHub的SSH keys设置在部署之前，需要保证GitHub可以验证我们的机器，需要将本地的RAS-publicKey告知给GitHub，步骤如下： 3.3.1 本地RAS密钥对生成进入到 用户目录/.ssh目录下，查看是否已经存在了， 私钥id_rsa 公钥id_rsa.pub1234C:\Users\Kang&gt; cd .sshC:\Users\Kang\.ssh&gt; dir-a---- 2018/10/10 19:46 1679 id_rsa-a---- 2018/10/10 19:46 403 id_rsa.pub 上面的输出表示已经存在。若不存在，执行 ssh-keygen 生成即可（持续回车即可）：123456789101112131415161718192021C:\Users\Kang\.ssh&gt; ssh-keygen.exe -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (C:\Users\Kang/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in C:\Users\Kang/.ssh/id_rsa.Your public key has been saved in C:\Users\Kang/.ssh/id_rsa.pub.The key fingerprint is:SHA256:ymf2laAmgHVsGakavggdXrzORtVRNxkuKYq444C5Irs kang@V1N3RYQG70NI7YDThe key&apos;s randomart image is:+---[RSA 2048]----+| .. .. +o || ..o. +.. || ...=...o . || o+++.... . || +o=oo. S . ||o.=.oo . . . . ||=.o= + * o ||++..+ * . . ||Eo.. . |+----[SHA256]-----+ -t rsa 表示使用的加密类型。生成过程可以输入一些信息，简单起见，全部回车即可。 生成完毕后，目录中应该存在相应文件了。 3.3.2 告知GitHub公钥在GitHub的用户设置中，找到ssh key的设置：SSH Keys点击 New SSH Key 新建将生成的公钥id_rsa.pub内容拷贝到输入框中，起名标志即可。保存即可。此时GitHub已经和我们本地电脑建立的信任关系。我们就可以将内容发布到GitHub上了。 3.4 部署到GitHub回到我们本地的博客项目中，hexo对于基于git的部署提供了一个工具hexo-deployer-git，我们直接安装使即可。 安装 hexo-deployer-git1$ npm install hexo-deployer-git --save 3.5 修改博客的部署配置需要指定部署类型，版本库地址，分支，消息等信息12345/_config.ymldeploy: type: git repo: https://github.com/yourusername/yourusername.github.io branch: master 3.6 执行部署部署的过程，是将本地博客先生成静态文件，然后将静态文件发布到指定的版本库中。因此总的过程应该是，清理之前的静态文件，生成新静态文件，发布到版本库 这个步骤，执行下面的代码即可：12$ hexo clean$ hexo deploy 部署deploy时会自动生成，因此可以省略 $ hexo generate 操作。 第一次部署的过程中，会出现要求输入GitHub账号信息的步骤，请输入即可： 等等过后，如果出现 Deploy done，类似的信息，说明部署完成。 也可以去版本库中查看是否已经存在代码了，版本库地址就是：https://github.com/yourusername/yourusername.github.io 部署完毕，就可以在 yourusername.github.io 看到你的博客了。 3.6 绑定域名过程如下： 1 申请域名，在域名供应商申请，例如万网（阿里云）。 2 添加解析到GitHub到IP，可以通过ping yourusername.github.io 获取，例如是：185.199.109.153。在域名供应商设置，例如万网（阿里云）。 3 在版本库中，增加一个CNAME。进入yourusername.github.io版本库，右上角setting，找到 Custom domain，设置好自己的域名即可。 4 总述完成以上部署后，博客完毕。写作流程就是，本地编辑md文件，本地预览ok后，发布到github即可！写作过程，请参考：Hexo文档。 有问题，欢迎留言讨论！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go-错误处理]]></title>
    <url>%2Fgo%2Fgo-error%2F</url>
    <content type="text"><![CDATA[宕机panicGo语言可以在程序中强行宕机。宕机时会将堆栈信息和goroutine信息输出到控制台，便于处理错误。示例语法：1panic(&quot;宕机信息&quot;) 运行后，得到：123456panic: 宕机信息goroutine 1 [running]:main.main() D:/projects/practice/go/syntax.go:45 +0x40exit status 2 宕机后，后续代码不再执行。但已经 defer 入栈的语句会在宕机前完成执行。 宕机恢复 recover当发生宕机时，会被 recover 捕获。执行完对应的 defer 后，从宕机点退出当前函数后继续执行，因此程序不会崩溃。配合使用 defer 和 recover，可以从宕机中恢复并捕获错误。达到宕机后继续运行的目的。无论是由 Runtime 层抛出的 panic 崩溃，还是主动触发的 panic 崩溃。可以理解成：panic 触发宕机类似于抛出异常 thrown，recover 宕机恢复机制就对应 try/catch。原理：语法上，利用 defer 的语句会在宕机前执行的机制，在代码执行前，先定义错误处理恢复方案，加入到defer栈中。再执行需要的代码。如果代码中出现宕机，会执行已经defer的代码，就是我们的宕机恢复处理代码。演示如下：123456789101112131415161718192021222324func main() &#123; func() &#123; // 先定义错误处理恢复方案，加入到defer栈中 defer func() &#123; // 发生宕机时，获取 panic 传递的上下文 err := recover() switch err.(type) &#123; case runtime.Error: // 运行时错误 fmt.Println(&quot;Runtime error:&quot;, err) default: // 非运行时错误 fmt.Println(&quot;User error:&quot;, err) &#125; &#125;() panic(&quot;强行宕机&quot;) // 或者 var pv *int *pv = 42 &#125;() fmt.Println(&quot;after panic&quot;)&#125; 以上代码，无论执行了 panic(&quot;强行宕机&quot;) 还是 *pv = 42 都不会导致系统崩溃，而是会去执行defer的函数，输出错误信息后，继续执行。就是after panic会永远执行。因为 recover 会恢复，结束 recover 所在函数后，代码继续！1234567&gt; go run .\syntax.goUser error: 强行宕机after panic或者&gt; go run .\syntax.goRuntime error: runtime error: invalid memory address or nil pointer dereferenceafter panic]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go提供的常用命令]]></title>
    <url>%2Fgo%2Fgo-command%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言使用strut处理面向对象]]></title>
    <url>%2Fgo%2Fgo-stuct%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言中指针的处理]]></title>
    <url>%2Fgo%2Fgo-point%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用vim编写Go语言]]></title>
    <url>%2Fgo%2Fgo-editor-vim%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言的反射机制]]></title>
    <url>%2Fgo%2Fgo-reflect%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用goland编写Go语言]]></title>
    <url>%2Fgo%2Fgo-editor-goland%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言使用类型管道channel处理并发]]></title>
    <url>%2Fgo%2Fgo-channel%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言的内存模型]]></title>
    <url>%2Fgo%2Fgo-memory-model%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言使用类型管道goroutine处理并发]]></title>
    <url>%2Fgo%2Fgo-goroutine%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
</search>
