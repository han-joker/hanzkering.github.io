<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go语言中的变量]]></title>
    <url>%2Fgo%2Fgo-variable%2F</url>
    <content type="text"><![CDATA[1 概述 2 定义：声明和初始化 3 类型默认值（零值） 4 强类型 5 类型推导 6 短声明（定义） 7 批量定义 8 批量赋值 9 匿名变量 10 变量作用域 1 概述变量（Variable）是程序运行过程中，内容可以变化（修改）的量，变量的功能是存储用户的数据，是计算机语言中能储存计算结果或能表示值抽象概念。变量，是通过变量的标识符定位值的过程。变量的内存模拟演示： 2 定义：声明和初始化定义变使用var关键字，需要指定其类型，可以同时初始化，如果没有指定初始化值，则使用类型的默认值，语法如下：1234// 声明变量，未初始化（默认值初始化）var name string// 声明变量，特定值初始化var user string = &quot;Hank&quot; Go语言中的变量必须声明后才可以使用，不能直接使用未定义的变量。 3 类型默认值（零值）Go语言的类型默认值如下所示： 整型和浮点型变量的默认值为 0。 字符串变量的默认值为空字符串。 布尔型变量默认为 bool。 切片、函数、指针变量的默认为 nil。 4 强类型Go语言是强类型语言，变量必须有类型，同时变量仅仅可以存储特定类型的数据。 5 类型推导定义变量时，如果指定了初始值，则可以省略类型的定义，Go语言可以自己由数据推导出类型。语法为：12// 声明变量，特定值初始化，类型推导出user为字符串string型var user = &quot;Hank&quot; 6 短声明（定义）为了简化定义变量，使用运算符 := 配合类型推导，可以快速完成变量的定义，语法为：1user := &quot;hank&quot; 7 批量定义使用var或:=都可以一次性定义多个变量，语法为：var123456var ( v1 = 42 v2 = &quot;hank&quot; )也可以var v1, v2 = 42, &quot;hank&quot; :=1v1, v2 := 42, &quot;hank&quot; 推荐使用 var() 声明块语法，因为代码维护容易。 8 批量赋值一次性为多个变量进行赋值。（类似短定义。v1, v2, v3 := 42, “hank”, false）当变量定义完毕后，再批量对其赋值，没有定义功能！语法为：123456var ( v1 int v2 int)// 批量赋值v1, v2 = 42, 1024 该语法，通常配合函数的批量返回来使用，一次性接收多个返回值，语法为：12345678910111213func main() &#123; var ( v1 int v2 int ) // 调用函数，接收其返回值 v1, v2 = getData()&#125;// 返回两个值的函数func getData() (int, int) &#123; // 返回了两个值（假设42为最小值，1024为最大值） return 42, 1024&#125; 非常方便的可以交换两个变量的值：123456var ( v1 = 42 v2 = 1024)// 交换v1, v2 = v2, v1 执行后，v1==1024, v2==42 9 匿名变量标识符为（下划线）的变量，是系统保留的匿名变量，在赋值后，会被立即释放，称之为匿名变量。其作用是变量占位符，对其变量赋值结构。通常会在批量赋值时使用。例如，函数返回多个值，我们仅仅需要其中部分，则不需要的使用来占位，演示：123456789101112func main() &#123; var ( v int ) // 调用函数，仅仅需要第二个返回值，第一，三使用匿名变量占位 _, v, _ = getData()&#125;// 返回两个值的函数func getData() (int, int, int) &#123; // 返回3个值 return 42, 1024, 2012&#125; 10 变量作用域Go语言中的变量是块作用域。块，指的是使用{}定义的代码段，包括函数，if/switch/for语句，或独立的{}都是块。在块内定义的变量仅仅在本块内可用。定义，指的是 var 或者 := 定义的变量。Go语言的作用域是层叠的，就是说内层块可以直接访问到外层块的变量，前提是内层块没有定义同名的外层变量。演示如下：12345678910111213141516171819202122232425// 全局（函数外）定义3个变量var ( v1 = 1 v2 = 2 v3 = 3)func main() &#123; // main&#123;&#125;函数块，定义2个变量 var ( v2 = 22 v3 = 33 ) fmt.Println(v1, v2, v3) // 结果 1 22 33 &#123; // main()函数内部&#123;&#125;块，定义1个变量 var ( v3 = 333 ) fmt.Println(v1, v2, v3) // 结果 1 22 333 &#125;&#125; 上面代码中：在main()中，v2，v3被重新定义，则在main()中，v1是外部，而v2, v3是main函数局部的。在main()内部的{}中，v3被重新定义，则在main()内部的{}中，v1是外部，而v2是main()定义的, v3是main()内部{}定义的的。 变量可以沿内部作用域向外部作用域查找变量的过程。 带有{}的语句，其中的变量也仅仅在内部有效，例如for，if，switch等，演示：12345for i := 0; i &lt; 10; i++ &#123; fmt.Println(i)&#125;fmt.Println(i)// 会提示变量i未定义, undefined: i 注意i，是通过短声明在for内部定义的变量，仅仅在for内部有意义。 互不嵌套的{}见作用域不可见，不可互相访问。123456789func main() &#123; &#123; v := 42 &#125; &#123; fmt.Println(v) // 会提示变量v未定义, undefined: v &#125;&#125; 一家之言，欢迎讨论！]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go-guide</tag>
        <tag>iota</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的常量]]></title>
    <url>%2Fgo%2Fgo-constant%2F</url>
    <content type="text"><![CDATA[1 概述 2 定义单个常量 3 类型推导 4 定义多个常量 5 iota迭代定义常量 6 常量在编译时确定 7 常量的作用 1 概述常量，一经定义不可更改的量。功能角度看，当出现不需要被更改的数据时，应该使用常量进行存储，例如圆周率。从语法的角度看，使用常量可以保证数据，在整个运行期间内，不会被更改。例如当前处理器的架构类型，可以保证不被更改。 语法如下 2 定义单个常量const 常量名 &lt;可选的类型&gt; = 常量值1const c1 int = 1000 Go语言中，标识符（常量名）是否大小写，取决于是否需要在导出时被识别。 常量的值仅仅支持，基础类型，字符串，字符，整型，浮点，布尔。 3 类型推导类型可以通过值推导出来，大多数情况可以省略类型，例如1const c2 = 1000 除非你想使用例如，int8, byte，float32这些非默认类型时，需要指定类型，例如1const c3 int16 = 1000 4 定义多个常量可以一行定义多个常量，例如：1const c4, c5 = 42, 1000 也可以使用 const()定义块，定义多个，每个常量单独一行，例如1234const ( c6 = 42 c7 = 1000) 推荐使用const()块语法，一次性定义多个。 const()块定义时，如果常量未给出定义，则延续上面的定义规则，例如：12345const ( c7 = 42 c8 // c8 = 42 c9 // c9 = 42) 此时，c8, c9, 值都是42。 5 iota迭代定义常量const配合iota关键字使用，可以定义一组由0开始+1迭代的常量演示语法：12345const ( gender_secret = iota gender_male // = iota gender_female // = iota) 此时，三个常量值，分别是,0, 1, 2iota的规则是：若iota出现在const()中，那么const()定义的第一行的iota就是0，第二行就是0+1=1，不论iota是否被常量使用。演示如下：12345678const ( c1 = 42 // iota = 0，虽然未使用iota，但后边（const()中）有使用，此时iota被初始化为0，下面每行累加1 c2 = iota // iota = 1，iota继续累加，使用了iota c3 = 1024 // iota = 2，同样未使用，但iota的值继续累加。c3 被定义为1024 c4 // iota = 3，c4延续上面的定义c4=1024，iota继续累加 c5 = iota // iota = 4，iota继续累加，使用了iota c6 = iota // iota = 5，iota继续累加，使用了iota) 此时结果为：42, 1, 1024, 1024, 4, 5 6 常量在编译时确定编译时确定，因此不能使用变量为其赋值。可以使用，确定的字面量，字面量运算，内置函数运算，其他定义常量，这些在编译时可以确定的内容为常量赋值，演示为：123456const c1 = &quot;hank&quot;const ( c2 = c1 c3 = 42 + 1024 c4 = len(&quot;hank&quot;)) 以上语法都可以！ 7 常量的作用 将特殊的值，语义化。使用时，可以知道其具体含义。 数据的集中管理，更改常量定义，即可完成全部的修改。 保证不被程序的其他代码所更改。 一家之言，欢迎讨论！]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go-guide</tag>
        <tag>iota</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go-editor-sublime]]></title>
    <url>%2Funcategorized%2Fgo-editor-sublime%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[git中使用merge和rebase的区别]]></title>
    <url>%2Fgit%2Fgit-merge-rebase%2F</url>
    <content type="text"><![CDATA[1 需求今天和朋友讨论了一下 分支间的整合方案，merge和rebase。以及pull操作模式。下面整理如下： 2 git pull做了什么 git-pull - Fetch from and integrate with another repository or a local branch译：从另一个版本库或本地分支拉取并与其整合 文档如上说，可见pull（拉取）执行了两个操作，他们是fetch（获取）和integrate（整合）。拉取就是将版本从远程拉取到本地，可以理解成下载。而整合指的是将拉取的版本与本地版本合并到一起。这个合并的操作，通常会有两种模式来实现，就是merge和rebase。 3 git merge合并 git-merge - Join two or more development histories together译：将两个或多个开发历史合并一起 merge，合并模式。指的是合并两个分支，最终的合并代码形成一个新的版本，两个分支的版本日志按照时间顺序合并到一起即可。 演示如下，git merge dev： 合并过程是，git会自动根据两个分支的共同祖先即v2，与两个分支的最新提交即master的v6和dev的v5进行一个三方合并，然后将合并中更新的内容生成一个新的版本即v6，内容合并完成后，会成立版本日志并记录。 merge的好处是版本不会出现错乱的情况（一会可以对比rebase，你会发现有错乱的情况），但多了一个额外的版本。（其实无所谓啦）再看rebase模式。 4 git rebase变基 git-pull - Reapply commits on top of another base tip译：在另一个的基本上重新应用提交 rebase，重设基础。指的是整合时，以另一个为基础（dev），将当前的（master）应用上去。演示如下，git rebase dev： 合并过程为，git会从两个分支的共同祖先即v2开始提取当前分支即master上的提交版本即v4和v5，将提取的修改v4和v6依次应用到目标分支dev的最新提交的后面。将master指向最新的合并版本。 从合并结果上看，rebase导致版本变为了：v1-&gt;v2-&gt;v3-&gt;v5-&gt;v4-&gt;v6，与真实的版本提交时间不一致了，就是发生了错乱。但rebase不会生成新的版本。 5 merge VS rebase该如何选择他们？ 当某个分支不再需要了（例如一个本地的bug分支，修复完毕就不在需要了），那么我们选择merge是合理的。 当我们的项目重启了，代码依赖的基础发生升级了，那么我们就可以rebase到这个升级之后的基础上继续开发。 rebase -i，一个交互式的rebase，可以用来编辑版本信息，可以获得更加整洁的版本日志。 千万不要在主体分支上使用rebase，否则会导致历史胡乱的。 如果git pull的时候，出现 error: failed to push some refs to &#39;版本库&#39;， 可以git pull --rebase来解决下，后面说明原因。 这个还需要再总结一下。 6 结束有问题，欢迎留言讨论！]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客，发布到GitHub]]></title>
    <url>%2Fhexo%2Fhexo-github%2F</url>
    <content type="text"><![CDATA[1 需求博客之前是wordpress搭建的，也很好用。现在想使用一个基于markdown文件为中心的博客系统，就锁定了hexo这个项目。hexo是基于Node.js的，提供markdown支持，草稿，单页，分类，标签，主题，i18n，永久链接，静态生成，部署等很常用的博客系统功能。其主页地址为：Hexo，大家可以获取更详细的信息。下面就和大家说说过程，大致有博客搭建，部署到github，还有另一个git服务器（个人的服务器）上的过程。 下面的操作的个人电脑为windows系统（win10)。 2 hexo搭建博客此步骤完成后，可以在自己本地电脑上，看到完整的博客系统了。 2.1 快速开始在安装好 Node.js, Git的基础上，执行下面代码即可12345$ npm install -g hexo-cli$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install$ hexo server 浏览器访问http://localhost:4000，即可看到你的博客。 如果没有Node.js或Git，请按照下面的步骤执行。 2.2 安装Node.jsNode.js是基于Chrome V8 JavaScript引擎的JavaScript运行环境(runtime built)。安装方式请参考Node.js官网 ，或者本站的Node.js相关内容。安装完毕后，应出现如下效果，表示安装成功：1234C:\Users\Kang&gt; node -vv8.12.0PS C:\Users\Kang&gt; npm -v6.4.1 安装Node.js还可以使用nvm（Node Version Manager，Node.js的版本管理工具）。使用nvm可以方便的安装Node.js的各种版本，以及在版本间进行切换。安装使用方式请参考windows下的nvm和linux下的nvm或者本站的Node.js相关内容。 2.3 安装GitGit是开源免费的分布式版本控制系统是用来处理代码量由小到大相关问题的。安装方式请参考Git官网，或者本站的Git相关内容。安装完毕后，应出现如下效果，表示安装成功：12C:\Users\Kang&gt; git versiongit version 2.19.1.windows.1 2.4 安装Hexo使用npm按照hexo即可，运行如下代码全局按照hexo-cli这个hexo的命令行工具1$ npm install -g hexo-cli 安装完毕后，应出现如下效果，表示安装成功：1234567891011121314151617C:\Users\Kang&gt; hexo -vhexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 8.12.0v8: 6.2.414.66uv: 1.19.2zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.32.0napi: 3openssl: 1.0.2picu: 60.1unicode: 10.0cldr: 32.0tz: 2017c 2.5 Hexo建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 选择好需要的站点目录（目录地址不要有中文）。例如选择 D:\projects\practice\blog&gt; 作为建站目录，那么执行如下操作即可：12345C:\Users\Kang&gt; d:D:\&gt; cd .\projects\practiceD:\projects\practice&gt; hexo init blogD:\projects\practice&gt; cd blogD:\projects\practice\blog&gt; npm install 此时一个基本的博客已经建立完毕了。 2.6 运行Hexo博客进入博客目录，执行 hexo server 即可运行hexo服务器。123D:\projects\practice\blog&gt; hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 此时，浏览器访问http://localhost:4000，即可看到你的博客。效果如下： 至此，hexo搭建的博客已经完成。该博客使用方法，如何发文章，分类，标签等操作请参考Hexo文档，本文不再赘述。 3.发布到GitHubGitHub上允许我们搭建自己的静态站点，在不购买自己的服务器情况下，可以有自己的博客。需要用到Hexo提供的发布相关功能，同时需要在github上做一定的配置。 3.1 注册GitHub 已有账号的跳过此步骤 注册操作，跟着GitHub引导完成即可，GitHub注册 3.2 创建版本库登录后，创建新版本库https://github.com/new 注意：版本库名字强烈建议是 &lt;你的用户&gt;.github.io 这种格式创建完毕后，就可以使用 &lt;你的用户&gt;.github.io 这种方式访问你的github博客地址，但现在访问应该不会成功，因为是一个新创建的版本库，是空的，一无所有….。接下来就把我们本地的博客内容部署到这个github版本库上。 3.3 GitHub的SSH keys设置在部署之前，需要保证GitHub可以验证我们的机器，需要将本地的RAS-publicKey告知给GitHub，步骤如下： 3.3.1 本地RAS密钥对生成进入到 用户目录/.ssh目录下，查看是否已经存在了， 私钥id_rsa 公钥id_rsa.pub1234C:\Users\Kang&gt; cd .sshC:\Users\Kang\.ssh&gt; dir-a---- 2018/10/10 19:46 1679 id_rsa-a---- 2018/10/10 19:46 403 id_rsa.pub 上面的输出表示已经存在。若不存在，执行 ssh-keygen 生成即可（持续回车即可）：123456789101112131415161718192021C:\Users\Kang\.ssh&gt; ssh-keygen.exe -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (C:\Users\Kang/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in C:\Users\Kang/.ssh/id_rsa.Your public key has been saved in C:\Users\Kang/.ssh/id_rsa.pub.The key fingerprint is:SHA256:ymf2laAmgHVsGakavggdXrzORtVRNxkuKYq444C5Irs kang@V1N3RYQG70NI7YDThe key&apos;s randomart image is:+---[RSA 2048]----+| .. .. +o || ..o. +.. || ...=...o . || o+++.... . || +o=oo. S . ||o.=.oo . . . . ||=.o= + * o ||++..+ * . . ||Eo.. . |+----[SHA256]-----+ -t rsa 表示使用的加密类型。生成过程可以输入一些信息，简单起见，全部回车即可。 生成完毕后，目录中应该存在相应文件了。 3.3.2 告知GitHub公钥在GitHub的用户设置中，找到ssh key的设置：SSH Keys点击 New SSH Key 新建将生成的公钥id_rsa.pub内容拷贝到输入框中，起名标志即可。保存即可。此时GitHub已经和我们本地电脑建立的信任关系。我们就可以将内容发布到GitHub上了。 3.4 部署到GitHub回到我们本地的博客项目中，hexo对于基于git的部署提供了一个工具hexo-deployer-git，我们直接安装使即可。 安装 hexo-deployer-git1$ npm install hexo-deployer-git --save 3.5 修改博客的部署配置需要指定部署类型，版本库地址，分支，消息等信息12345/_config.ymldeploy: type: git repo: https://github.com/yourusername/yourusername.github.io branch: master 3.6 执行部署部署的过程，是将本地博客先生成静态文件，然后将静态文件发布到指定的版本库中。因此总的过程应该是，清理之前的静态文件，生成新静态文件，发布到版本库 这个步骤，执行下面的代码即可：12$ hexo clean$ hexo deploy 部署deploy时会自动生成，因此可以省略 $ hexo generate 操作。 第一次部署的过程中，会出现要求输入GitHub账号信息的步骤，请输入即可： 等等过后，如果出现 Deploy done，类似的信息，说明部署完成。 也可以去版本库中查看是否已经存在代码了，版本库地址就是：https://github.com/yourusername/yourusername.github.io 部署完毕，就可以在 yourusername.github.io 看到你的博客了。 3.6 绑定域名过程如下： 1 申请域名，在域名供应商申请，例如万网（阿里云）。 2 添加解析到GitHub到IP，可以通过ping yourusername.github.io 获取，例如是：185.199.109.153。在域名供应商设置，例如万网（阿里云）。 3 在版本库中，增加一个CNAME。进入yourusername.github.io版本库，右上角setting，找到 Custom domain，设置好自己的域名即可。 4 总述完成以上部署后，博客完毕。写作流程就是，本地编辑md文件，本地预览ok后，发布到github即可！写作过程，请参考：Hexo文档。 有问题，欢迎留言讨论！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>github</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go提供的常用命令]]></title>
    <url>%2Fgo%2Fgo-command%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言使用strut处理面向对象]]></title>
    <url>%2Fgo%2Fgo-stuct%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的一等公民——函数]]></title>
    <url>%2Fgo%2Fgo-function%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言中指针的处理]]></title>
    <url>%2Fgo%2Fgo-point%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用vim编写Go语言]]></title>
    <url>%2Fgo%2Fgo-editor-vim%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言的反射机制]]></title>
    <url>%2Fgo%2Fgo-reflect%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用goland编写Go语言]]></title>
    <url>%2Fgo%2Fgo-editor-goland%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言使用类型管道channel处理并发]]></title>
    <url>%2Fgo%2Fgo-channel%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言的内存模型]]></title>
    <url>%2Fgo%2Fgo-memory-model%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言使用类型管道goroutine处理并发]]></title>
    <url>%2Fgo%2Fgo-goroutine%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言模块化项目管理]]></title>
    <url>%2Fgo%2Fgo-module%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
</search>
