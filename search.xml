<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go语言中结构体的使用-第2部分OOP]]></title>
    <url>%2Fgo%2Fgo-struct-ii%2F</url>
    <content type="text"><![CDATA[1 概述结构体的基本语法请参见：Go语言中结构体的使用-第1部分结构体。结构体除了是一个复合数据之外，还用来做面向对象编程。Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性。也就意味着结构体类型可以类比为其他语言中的“类class”, 而结构体数据可以类比为其他语言中的 “对象”。本文就说说结构体中，面向对象的部分。 2 构造工厂函数在面向对象编程中，实例化对象时往往需要完成很多业务逻辑，例如初始数据合理性，获取需要的资源等。在经典的OOP程序中，都会提供构造方法，用于在实例化对象时完成特定功能。Go语言中，没有class，因此没有典型意义的构造方法。但我们可以定义一个函数，用来实例化结构体对象，在函数内完成特定功能，实现构造函数的功能，这就是构造工厂函数。演示如下：12345678910111213141516type Product struct &#123; Name string Price float64&#125;func NewProduct(name string, price float64) *Product &#123; // 此处完成初始化业务逻辑 // 得到Product对象 return &amp;Product&#123; Name: name, Price: price, &#125;&#125;// 需要 Product 对象时：p := NewProduct(&quot;ThinkPad T480&quot;, 8008) 注意，在OOP编程中，通常认为对象是引用用传递，因此我们的构造函数返回的是 *Product 同时函数内使用 &amp;Product ，这样得到的对象为引用传递（Go语言对结构体类型自动解析引用）。 3 成员方法（接收器）若要为成员增加方法，需要在函数上定义接收器，用来接收调用该方法的成员对象。接收器定义如下：123func (p *Product) Sale() &#123; fmt.Println(&quot;Product: &quot;, p.name, &quot; is on Sale&quot;)&#125; 语法中，(p *Product) 就是接收器。通过定义可知，该接收器可以让函数接受一个 *Product 类型的参数，也就是调用该函数的对象。调用方法为：123456pro := &amp;Product&#123; name: &quot;ThinkPad T480&quot;&#125;// 当作成员去调用// 调用时，将调用函数的 pro，作为参数传递给函数 Run 的接收器 m。这样就可以访问 pro 对象了。pro.Sale() 同样，面向对象中对象通常为引用类型，因此接收器的定义也是 *Product 的引用类型。 4 继承，内嵌结构体Go语言中结构体对象间的继承，通过内嵌结构体语法实现。演示：12345678910111213type Product struct &#123; Name string Price float64&#125;func (p *Product) Sale() &#123; fmt.Println(&quot;Product: &quot;, p.name, &quot; is on Sale&quot;)&#125;type Book struct &#123; // 嵌入Product结构体 Product Author string Publish string&#125; 定义 Book 时，内嵌了 Product 结构体。其中 Book 称为子结构体（派生，扩展），Product成为父结构体（基础）。实例化的 Book 结构体对象，可以直接访问 Product 结构体中定义的成员包括属性和方法。演示：123456v := &amp;Book&#123;&#125;// 访问内嵌结构体属性v.Name = &quot;笑傲江湖&quot;v.Author = &quot;金庸&quot;// 调用内嵌结构体方法v.Sale() 内嵌还支持：多继承，可以同时内嵌多个结构体，称之为多继承。但要保证所继承的结构体间没有同名成员，否则出错。 间接访问，字结构体对象支持通过父结构体对象访问继承的成员，语法为 v.Product.Name，效果与 v.Name 一致。可以理解为是一种快捷语法。 直接初始化，可以直接为内嵌结构体提供初始化操作。演示为：1234567p := &amp;Book&#123; Product: &amp;Product&#123; Name: &quot;天龙八部&quot; Price: 42.8 &#125; Author: &quot;金庸&quot;&#125; 5 重写，override在内嵌继承中，若子与父结构体存在同名成员，实例化的子结构体成员，访问到的是字结构体定义的成员。这个现象称之为重写override。演示：1234567891011121314151617181920type Product struct &#123; Name string Price float64&#125;func (p *Product) Sale() &#123; fmt.Println(&quot;Product: &quot;, p.name, &quot; is on Sale&quot;)&#125;type Book struct &#123; // 嵌入Product结构体 Product Author string Publish string Price float64&#125;v := &amp;Book&#123;&#125;// 访问内嵌结构体属性// 以下代码访问的是 Book 中定义的 Price 属性v.Price = 42.8// 测试：fmt.Println(v.Product.Price) // 结果为 0 以上就是结构体提供的关于OOP中的语法。OOP编程还会涉及到接口，反射等技术。 结构体第二部分完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中结构体的使用-第1部分结构体]]></title>
    <url>%2Fgo%2Fgo-struct-i%2F</url>
    <content type="text"><![CDATA[1 概述 2 定义语法 3 实例化 4 值类型 5 初始化属性 6 . 成员访问运算符点号 7 匿名结构体 1 概述结构体是由成员构成的复合类型。Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性。结构体成员，也可称之为成员变量，字段，属性。属性要满足唯一性。结构体的概念在软件工程上旧的术语叫 ADT（抽象数据类型：Abstract Data Type）数据层面，结构体是自定义数据类型，可以理解成是由一系列具有相同或不同类型的数据构成的数据集合。因此结构体也被称之为抽象数据类型（ADT，Abstract Data Type）。在Go语言中，结构体承担着面向对象语言中类的作用。 Go语言中，结构体本身仅用来定义属性。还可以通过接收器函数来定义方法，使用内嵌结构体来定义继承。这样使用结构体相关操作Go语言就可以实现OOP面向对象编程了。 我们先看结构体相关语法，再看OOP相关的。 2 定义语法12345678910type identifier struct &#123; field1 type1 field2 type2 ...&#125;// 或者 同一类型的字段，可以定义在一行type identifier struct &#123; field1, field2 int&#125; 3 实例化Go语言提供了以下几种方法实例化：12345// T表示结构体标识符，v结构体变量var v T v := T&#123;&#125; // var v = T&#123;&#125;v := new(T)v := &amp;T&#123;&#125; // var v = &amp;T&#123;&#125; 以上方法中，var v T 和 v := T{} // var v = T{} 会返回结构体变量，而 v := new(T) 和 v := &amp;T{} // var v = &amp;T{} 会返回结构体指针。 4 值类型注意，结构体是值类型，不是引用类型。因此使用不同方式实例化的，在赋值时效果时不一样的，需要注意。 var v T 和 v := T{} // var v = T{} 值传递。v := new(T) 和 v := &amp;T{} // var v = &amp;T{} 引用地址传递。 Go语言会对结构体类型指针做自解析。也就是说，即使获得的是结构体指针，也不需要使用 *v 的语法。12345v := &amp;T&#123;&#125;// 直接使用v.语法即可。自动解析了 *vv.field// 相当于，也可以这么用(*v).field 5 初始化属性使用类似于键值对的语法初始化结构体属性，但此处的键指的是结构体内字段：12345v := T&#123; field1: value1, field2: value2, …&#125; 如果我们初始化全部的结构体字段，可以按照定义顺序仅仅使用数据部分即可完成初始化：123456// 要满足全部字段，按照定义顺序v := T&#123; value1, value2, value3,&#125; 6 . 成员访问运算符点号要访问结构体成员，需要使用点号 . 操作符，格式为：12345v.field// 获取fmt.Println(v.field)// 设置v.field = new-value 7 匿名结构体匿名结构体没有类型名称，只有字段和类型定义，无须通过type关键字定义就可以直接使用。匿名结构体的初始化写法由结构体定义和键值对初始化两部分组成。如下所示：1234567v := struct &#123; field1 type1 field2 type2&#125;&#123; field1: value1, field2: value2,&#125; 注意，匿名结构体，必须要同时初始化，不能仅仅定义匿名结构体。当需要使用一个临时结构体类型时，可以使用匿名结构体。 第一部分完！后续部分为 构造函数，方法，继承 与OOP相关的内容。原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中映射表map的使用]]></title>
    <url>%2Fgo%2Fgo-map%2F</url>
    <content type="text"><![CDATA[1 概述Go语言中的键值对(key-&gt;value)集合，称之为映射map。映射map是变长类型，定义时不需要指定长度。映射map是无序的，遍历是的顺序不可期，原因是底层由hash表实现。逻辑结构表示为： 2 创建语法12345678910var m = map[key_type]value_type&#123;key1: value1, key2: value2&#125;var m = make(map[key_type]value_type)// 示例,字符串型下标，字符串型值：var m = make(map[string]string) //make()会分配内存空间，初始化。m[&quot;east&quot;] = &quot;东&quot;m[&quot;west&quot;] = &quot;西&quot;// 直接初始化var m = map[string]string&#123;&quot;east&quot;: &quot;东&quot;, &quot;west&quot;: &quot;西&quot;&#125; 3 []下标操作与数组类型，使用下标完成映射元素的访问。12345var m = map[string]string&#123;&quot;east&quot;: &quot;东&quot;, &quot;west&quot;: &quot;西&quot;&#125;fmt.Println(m[&quot;east&quot;]) // 东fmt.Println(m[&quot;west&quot;]) // 西 4 for-range123for k, v := range mapVar &#123; fmt.Println(k, v)&#125; 遍历的顺序不可期。 5 映射是引用类型切片为引用类型，因此切片的默认初始值为nil。同时复制时为引用传递，修改会相互影响。 6 检测元素是否存在通过key获取元素时，使用第二个变量，可以接收到当前key是否存在的布尔值。123456var m = map[string]string&#123;&quot;east&quot;: &quot;东&quot;, &quot;west&quot;: &quot;西&quot;&#125;value, exists := m[&quot;south&quot;]// value: 东， exists: truevalue, exists := m[&quot;south&quot;]// value: ， exists: false 7 delete 删除元素delete(map, key)，删除 map 中，指定的 key。如果 key 不存在，该操作不会产生错误。1234var m = map[string]string&#123;&quot;east&quot;: &quot;东&quot;, &quot;west&quot;: &quot;西&quot;&#125;delete(m, &quot;west&quot;)fmt.Println(m)// map[east:东] 8 键值对调如果 map 的值类型可以作为 key 且所有的 value 是唯一的，那么通过下面的方法可以做到键值对调：1234var m = map[string]string&#123;&quot;east&quot;: &quot;东&quot;, &quot;west&quot;: &quot;西&quot;&#125;for k, v := range m &#123; m[v] = k&#125; 完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中切片的使用]]></title>
    <url>%2Fgo%2Fgo-slice%2F</url>
    <content type="text"><![CDATA[1 概述其中切片是基于数据中连续片段的引用，是一个引用类型。与数组不同的是，切片的长度可以在运行时修改。使用上可以将切片看作是长度可变的数组。即使超过了底层数组的最大长度，也可以继续扩容。 图例为： 切片的实现是由一个底层数组以及其上面的动态位置，尺寸来实现。由内部由指向起始元素的指针、元素数量length和容量capacity组成。其中： 指针ptr，用于指向切片在底层数组的起始位置。 尺寸len，用于记录切片内元素数量。 容量cap，当前切片最大容量，也就是底层数组的容量。可以动态分配。 当使用不定数量参数时，函数得到的参数也是切片类型。 切片为引用类型，因此切片的默认初始值为nil。 2 创建切片语法整理如下： []type，切片类型 []type{v1, v2, v3}，定义时指定初始值 make([]type, len)，make开辟内存空间，指定类型和长度 make([]type, len, cap)，make开辟切片内存空间，指定类型，长度和容量 arr[start:end:max]，由数组或切片创建其中：开始索引start，表示从哪个元素开始。结束索引end，表示到哪个索引终止，不包括该索引元素。最大索引max，用来确定容量，容量=最大索引-开始索引。默认情况下，最大索引的值为len()。 3 for-range 遍历123for i, v := range sli &#123; fmt.Println(i, v)&#125; 4 append() 扩容func append(s []T, x …T) []T使用 buildin 函数 append() 可以向切片中添加新元素。添加时存在两种情况： 切片容量充足，在原切片基础上追加。 切片容量不足，会分配新的切片空间来保证已有切片元素和新增元素的存储。 123456789101112131415s1 := make([]int, 3, 5)s2 := append(s1, 1, 2)s2[1] = 42fmt.Println(s1)fmt.Println(s2)// [0 42 0] 修改s2，s1也会更改// [0 42 0 1 2]s3 := make([]int, 3, 5)s4 := append(s1, 1, 2, 3, 4, 5)s4[1] = 42fmt.Println(s3)fmt.Println(s4)// [0 0 0] 修改s4，s3不会更改，因为容量不足，开辟了新空间// [0 42 0 1 2 3 4 5] 可以将一个切片到另一个切片后，需要使用 切片… 来实现：1append(slice1, slice2…) 5 copy() 拷贝切片由于默认是地址传递赋值方式，当需要得到一个新的拷贝时，需要使用函数copy()来实现。copy(新切片，旧切片)，利用旧切片复制一份新切片。 123s3 := []int&#123;10, 20, 30&#125;var s4 = make([]int, 3)copy(s4, s3) 6 常用操作配合 make，append，copy 可以完成切片的常用操作。 通过索引 i 删除切片中某个元素1s2 := append(s1[:i], s1[i+1:]...) 删除索引 i-j 的元素1s2 := append(append([]int&#123;&#125;, s1[:i]...), s1[j:]...) 在索引 i 的位置插入元素1s2 := append(s1[:i], append([]int&#123;v&#125;, s1[i:]...)...) 在 s1 索引 i 的位置插入切片 s2 的所有元素1s1 = append(s1[:i], append(s2, s1[i:]...)...) 栈操作模拟12345678910111213141516171819// 栈模拟（只在一端的头，添加或者删除元素）var s1 = []int&#123;6, 7, 8, 9, 10, 11&#125;// 操作末尾// 入栈s1 = append(s1, 12)fmt.Println(s1)// 出栈v := s1[len(s1)-1]s1 = s1[:len(s1)-1]fmt.Println(v, s1)// 操作头部// 入栈s1 = append([]int&#123;5&#125;, s1...)fmt.Println(s1)// 出栈v := s1[0]s1 = s1[1:]fmt.Println(v, s1) 队列操作模拟123456789101112// 模拟队列// 头进尾出var s1 = []int&#123;6, 7, 8, 9, 10, 11&#125;s1 = append([]int&#123;5&#125;, s1...)v := s1[len(s1)-1]s1 = s1[:len(s1)-1]// 尾进头出var s1 = []int&#123;6, 7, 8, 9, 10, 11&#125;s1 = append(s1, 12)v := s1[0]s1 = s1[1:] 完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中数组的使用]]></title>
    <url>%2Fgo%2Fgo-array%2F</url>
    <content type="text"><![CDATA[1 概述数组，切片，map是容器数据类型。都是可以存储多个值的符合类型。其中数组是相同类型的一组已编号且长度固定的数据项序列，不用类型和长度是不同的数据类型，例如[5]int, [3]int, [5]byte是不同的类型。 2 定义语法12345678910111213// 定义长度和类型，默认使用类型零值进行初始化var a1 [10]int// 定义长度和类型，同时初始化部分（全部）元素// 元素不够从前到后进行初始化var a2 = [10]int&#123;1, 2, 3, 4, 5&#125;// 不指定长度，指定类型。使用初始值确定长度// 有几个初始值，长度就是几var a3 = [...]int&#123;1, 2, 3, 4, 5, 6&#125;// 通过索引确定元素值var a4 = [10]int&#123;0: 1, 3: 2, 5: 3, 4, 5&#125; 3 []索引访问索引（index），是从 0 开始，加 1 递增的。使用 [] 访问。12arr[0] // 数组的第一个元素arr[len(arr)-1] // 数组的最后一个元素 4 数组是值类型数组为值类型，赋值时会生成新拷贝。这个可能和你熟悉的语言不同，稍稍留意。 5 len() 长度统计元素个数，一维的统计。如果是多维，仅统计一维元素数量。 6 数组遍历使用 循环索引 或者 for range 的语法完成遍历。1234567891011// 循环索引var arr = [...]string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125;for i, l := 0, len(arr); i &lt; l; i++ &#123; fmt.Println(arr[i])&#125;// for rangevar arr = [...]string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;&#125;for i, v := range arr &#123; fmt.Println(i, v)&#125; 7 多维数组数组元素的值可以是数组类型，称之为多维数组，要求内部数组的长度相同。以二维数组为例，使用[][]来定义，可以将二维数组想象成一个行列表格。12var a1 [3][5]intvar a2 = [3][5]string&#123;&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;, &#123;&quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;&#125;, &#123;&quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;&#125;&#125; 以上代码就定了二维数组，第一个使用默认值初始，第二个手动填充。 演示如下 使用双层循环可以遍历二维数组：123456789101112131415161718// 循环索引// 行坐标索引for i := 0; i &lt; 3; i++ &#123; // 列坐标索引 for j := 0; j &lt; 5; j++ &#123; fmt.Print(a2[i][j], &quot; &quot;) &#125; fmt.Println()&#125;// for rangefor _, row := range a2 &#123; // fmt.Println(i, row) for _, value := range row &#123; fmt.Print(value, &quot; &quot;) &#125; fmt.Println()&#125; 8 数组传参数组是值类型，传参时会发生值拷贝，当使用大数组时，内存的消耗需要考虑。可以考虑使用数组指针或者切片类型。12func FuncName(p *[9999]float64) &#123;&#125; 9 ==，!= 数组间的比较两个数组的类型，长度，元素值，顺序都相同，认为两个数组相等。12345678[3]&#123;1, 2, 3&#125; == [4]&#123;1, 2, 3, 4&#125;// false[3]&#123;1, 2, 3&#125; == [3]&#123;3, 2, 1&#125;// false[3]&#123;1, 2, 3&#125; == [3]&#123;1, 2, 3&#125;// true 完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中其他数据与字符串类型的转换]]></title>
    <url>%2Fgo%2Fgo-strconv%2F</url>
    <content type="text"><![CDATA[1 概述 2 与切片的转换 3 strconv 包 strconv.Atoi(s string) (int, error) strconv.Itoa(i int) string strconv.ParseFloat(s string, bitSize int) (float64, error) strconv.ParseInt(s string, base int, bitSize int) (i int64, err error) strconv.FormatFloat(f float64, fmt byte, prec, bitSize int) string strconv.FormatInt(i int64, base int) string strconv.AppendBool(dst []byte, b bool) []byte strconv.AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte strconv.AppendInt(dst []byte, i int64, base int) []byte strconv.AppendQuote(dst []byte, s string) []byte strconv.AppendQuoteRune(dst []byte, r rune) []byte strconv.AppendQuoteRuneToASCII(dst []byte, r rune) []byte strconv.AppendQuoteToASCII(dst []byte, s string) []byte strconv.AppendUint(dst []byte, i uint64, base int) []byte strconv.CanBackquote(s string) bool strconv.FormatBool(b bool) string strconv.FormatUint(i uint64, base int) string strconv.IsPrint(r rune) bool strconv.ParseBool(str string) (bool, error) strconv.ParseUint(s string, base int, bitSize int) (uint64, error) strconv.Quote(s string) string strconv.QuoteRune(r rune) string strconv.QuoteRuneToASCII(r rune) string strconv.QuoteToASCII(s string) string strconv.Unquote(s string) (string, error) strconv.UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error) 1 概述Go语言是强类型语言，因此总会需要将字符串转成需要的类型。比如整型和字符串转换，字符串和布尔型的转换等。本文就介绍如何完成这些转换，以下是Go语言关于字符串转换的整理说明，主要是与切片类型的转换，和 strconv 包的使用。 2 与切片的转换切片类型可以和字符串类型相互转换。123456789fmt.Println([]rune(&quot;Hello小韩说课&quot;))// [72 101 108 108 111 23567 38889 35828 35838]fmt.Println(string([]rune&#123;72, 101, 108, 108, 111, 23567, 38889, 35828, 35838&#125;))// Hello小韩说课fmt.Println([]byte(&quot;Hello&quot;))// [72 101 108 108 111]fmt.Println(string([]byte&#123;72, 101, 108, 108, 111&#125;))// Hello 3 strconv 包会将常用的放在前面： strconv.Atoi(s string) (int, error)转换字符串 s string 到整型。12345678v := &quot;10&quot;if s, err := strconv.Atoi(v); err == nil &#123; fmt.Printf(&quot;%T, %v&quot;, s, s)&#125;// int, 10// 相当于strconv.ParseInt(s, 10, 0) strconv.Itoa(i int) string将整型转 i int 换为字符串1234i := 10s := strconv.Itoa(i)fmt.Printf(&quot;%T, %v\n&quot;, s, s)// string, 10 strconv.ParseFloat(s string, bitSize int) (float64, error)解析字符 str string 串为浮点，可以设置位数。123456789v := &quot;3.1415926535&quot;if s, err := strconv.ParseFloat(v, 32); err == nil &#123; fmt.Printf(&quot;%T, %v\n&quot;, s, s)&#125;// float64, 3.1415927410125732if s, err := strconv.ParseFloat(v, 64); err == nil &#123; fmt.Printf(&quot;%T, %v\n&quot;, s, s)&#125;// float64, 3.1415926535 strconv.ParseInt(s string, base int, bitSize int) (i int64, err error)解析字符 str string 串为整数，可以设置进制、位数。1234567891011121314151617v32 := &quot;-354634382&quot;if s, err := strconv.ParseInt(v32, 10, 32); err == nil &#123; fmt.Printf(&quot;%T, %v\n&quot;, s, s)&#125;if s, err := strconv.ParseInt(v32, 16, 32); err == nil &#123; fmt.Printf(&quot;%T, %v\n&quot;, s, s)&#125;// int64, -354634382v64 := &quot;-3546343826724305832&quot;if s, err := strconv.ParseInt(v64, 10, 64); err == nil &#123; fmt.Printf(&quot;%T, %v\n&quot;, s, s)&#125;if s, err := strconv.ParseInt(v64, 16, 64); err == nil &#123; fmt.Printf(&quot;%T, %v\n&quot;, s, s)&#125;// int64, -3546343826724305832 strconv.FormatFloat(f float64, fmt byte, prec, bitSize int) string将浮点数 f float64 转换为字符串，可以设置格式 fmt（b,e,E,f,g,G）、精度prce、位数（32或64）。1234567v := 3.1415926535s32 := strconv.FormatFloat(v, &apos;E&apos;, -1, 32)fmt.Printf(&quot;%T, %v\n&quot;, s32, s32)// string, 3.1415927E+00s64 := strconv.FormatFloat(v, &apos;E&apos;, -1, 64)fmt.Printf(&quot;%T, %v\n&quot;, s64, s64)// string, 3.1415926535E+00 strconv.FormatInt(i int64, base int) string将整数 i int64 转换为字符串，可以指定进制 base。1234567v := int64(-42)s10 := strconv.FormatInt(v, 10)fmt.Printf(&quot;%T, %v\n&quot;, s10, s10)// string, -42s16 := strconv.FormatInt(v, 16)fmt.Printf(&quot;%T, %v\n&quot;, s16, s16)// string, -2a strconv.AppendBool(dst []byte, b bool) []byte将布尔值 b bool 以字符串形式追加到 dst []byte 中。1234567b := []byte(&quot;bool:&quot;)b = strconv.AppendBool(b, true)fmt.Println(string(b))// bool:true// 相当于append(dst []byte, strconv.FormatBool(b bool)) strconv.AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte将浮点数 f float64 以字符串形式追加到 dst []byte 中，可以设置格式 fmt（b,e,E,f,g,G）、精度prce、位数（32或64）。123456789101112b32 := []byte(&quot;float32:&quot;)b32 = strconv.AppendFloat(b32, 3.1415926535, &apos;E&apos;, -1, 32)fmt.Println(string(b32))// float32:3.1415927E+00b64 := []byte(&quot;float64:&quot;)b64 = strconv.AppendFloat(b64, 3.1415926535, &apos;E&apos;, -1, 64)fmt.Println(string(b64))// float64:3.1415926535E+00// 相当于append(dst []byte, strconv.FormatFloat(3.1415926535, &apos;E&apos;, -1, 64)) strconv.AppendInt(dst []byte, i int64, base int) []byte将整数 i int64 以字符串形式追加到 dst []byte 中，可以指定进制。12345678910111213b10 := []byte(&quot;int (base 10):&quot;)b10 = strconv.AppendInt(b10, -42, 10)fmt.Println(string(b10))// int (base 10):-42b16 := []byte(&quot;int (base 16):&quot;)b16 = strconv.AppendInt(b16, -42, 16)fmt.Println(string(b16))// int (base 16):-2a// 相当于append(dst []byte, strconv.FormatInt(-42, 10))append(dst []byte, strconv.FormatInt(-42, 16)) strconv.AppendQuote(dst []byte, s string) []byte将字符串 s string 以字符串双引号定义的形式追加到 dst []byte 中。1234567b := []byte(&quot;quote:&quot;)b = strconv.AppendQuote(b, `&quot;Fran &amp; Freddie&apos;s Diner&quot;`)fmt.Println(string(b))// quote:&quot;\&quot;Fran &amp; Freddie&apos;s Diner\&quot;&quot;// 相当于append(dst []byte, strconv.Quote(`&quot;Fran &amp; Freddie&apos;s Diner&quot;`)) strconv.AppendQuoteRune(dst []byte, r rune) []byte将字符 r rune 以字单引号定义的形式追加到 dst []byte 中。1234567b := []byte(&quot;rune:&quot;)b = strconv.AppendQuoteRune(b, &apos;☺&apos;)fmt.Println(string(b))// rune:&apos;☺&apos;// 相当于append(dst []byte, strconv.QuoteRune(&apos;☺&apos;)) strconv.AppendQuoteRuneToASCII(dst []byte, r rune) []byte将字符 r rune 以字单引号定义的形式追加到 dst []byte 中，对于非 ASCII 字符 r 会以转义字符的形式出现。1234567b := []byte(&quot;rune (ascii):&quot;)b = strconv.AppendQuoteRuneToASCII(b, &apos;☺&apos;)fmt.Println(string(b))// rune (ascii):&apos;\u263a&apos;// 相当于append(dst []byte, strconv.QuoteRuneToASCII(&apos;☺&apos;)) strconv.AppendQuoteToASCII(dst []byte, s string) []byte将字符串 s string 以字符串双引号定义的形式追加到 dst []byte 中，非 ASCII 字符以转义形式表示。1234567b := []byte(&quot;quote (ascii):&quot;)b = strconv.AppendQuoteToASCII(b, `&quot;Fran &amp; Freddie&apos;s Diner&quot;`)fmt.Println(string(b))// quote (ascii):&quot;\&quot;Fran &amp; Freddie&apos;s Diner\&quot;&quot;// 相当于append(dst []byte, strconv.QuoteToASCII(`&quot;Fran &amp; Freddie&apos;s Diner&quot;`)) strconv.AppendUint(dst []byte, i uint64, base int) []byte将无符号整数 i uint64 以字符串形式追加到 dst []byte 中，可以指定进制。123456789b10 := []byte(&quot;uint (base 10):&quot;)b10 = strconv.AppendUint(b10, 42, 10)fmt.Println(string(b10))// uint (base 10):42b16 := []byte(&quot;uint (base 16):&quot;)b16 = strconv.AppendUint(b16, 42, 16)fmt.Println(string(b16))// uint (base 16):2a strconv.CanBackquote(s string) bool检测字符串 s string 是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串。1234fmt.Println(strconv.CanBackquote(&quot;Fran &amp; Freddie&apos;s Diner ☺&quot;))// truefmt.Println(strconv.CanBackquote(&quot;`can&apos;t backquote this`&quot;))// false strconv.FormatBool(b bool) string将布尔 b bool 转换为字符串。1234v := trues := strconv.FormatBool(v)fmt.Printf(&quot;%T, %v\n&quot;, s, s)// string, true strconv.FormatUint(i uint64, base int) string将无符号整数 i uint64 转换为字符串，可以指定进制 base。12345678v := uint64(42)s10 := strconv.FormatUint(v, 10)fmt.Printf(&quot;%T, %v\n&quot;, s10, s10)// string, 42s16 := strconv.FormatUint(v, 16)fmt.Printf(&quot;%T, %v\n&quot;, s16, s16)// string, 2a strconv.IsPrint(r rune) bool检测字符 r rune 是否为打印字符。1234567c := strconv.IsPrint(&apos;\u263a&apos;)fmt.Println(c)// truebel := strconv.IsPrint(&apos;\007&apos;)fmt.Println(bel)// false strconv.ParseBool(str string) (bool, error)解析字符 str string 串为布尔型。12345v := &quot;true&quot;if s, err := strconv.ParseBool(v); err == nil &#123; fmt.Printf(&quot;%T, %v\n&quot;, s, s)&#125;// bool, true strconv.ParseUint(s string, base int, bitSize int) (uint64, error)解析字符 str string 串为无符号整数，可以设置进制、位数。123456789v := &quot;42&quot;if s, err := strconv.ParseUint(v, 10, 32); err == nil &#123; fmt.Printf(&quot;%T, %v\n&quot;, s, s)&#125;// uint64, 42if s, err := strconv.ParseUint(v, 10, 64); err == nil &#123; fmt.Printf(&quot;%T, %v\n&quot;, s, s)&#125;// uint64, 42 strconv.Quote(s string) string返回字符串 s string 双引号字面值表示，控制字符、不可打印字符会进行转义，如 \t，\n，\xFF，\u0100。123s := strconv.Quote(`&quot;Fran &amp; Freddie&apos;s Diner ☺&quot;`)fmt.Println(s)// &quot;\&quot;Fran &amp; Freddie&apos;s Diner\t☺\&quot;&quot; strconv.QuoteRune(r rune) string返回字符 r rune 单引号字面值表示，控制字符、不可打印字符会进行转义，如\t，\n，\xFF，\u0100。123s := strconv.QuoteRune(&apos;☺&apos;)fmt.Println(s)// &apos;☺&apos; strconv.QuoteRuneToASCII(r rune) string返回字符 r rune 单引号字面值表示，控制字符、不可打印字符、非ASCII字符会进行转义。123s := strconv.QuoteRuneToASCII(&apos;☺&apos;)fmt.Println(s)// &apos;\u263a&apos; strconv.QuoteToASCII(s string) string返回字符串 s string 双引号字面值表示，控制字符和不可打印字符、非ASCII字符会进行转义。123s := strconv.QuoteToASCII(`&quot;Fran &amp; Freddie&apos;s Diner ☺&quot;`)fmt.Println(s)// &quot;\&quot;Fran &amp; Freddie&apos;s Diner\t\u263a\&quot;&quot; strconv.Unquote(s string) (string, error)返回一个单引号、双引号、反引号包围的语法字符串 s string，解析它并返回它表示的值。若为反引号括起来的，函数会认为s是go字符字面值，返回一个单字符的字符串。123456789101112131415s, err := strconv.Unquote(&quot;You can&apos;t unquote a string without quotes&quot;)fmt.Printf(&quot;%q, %v\n&quot;, s, err)// &quot;&quot;, invalid syntaxs, err = strconv.Unquote(&quot;\&quot;The string must be either double-quoted\&quot;&quot;)fmt.Printf(&quot;%q, %v\n&quot;, s, err)// &quot;The string must be either double-quoted&quot;, &lt;nil&gt;s, err = strconv.Unquote(&quot;`or backquoted.`&quot;)fmt.Printf(&quot;%q, %v\n&quot;, s, err)// &quot;or backquoted.&quot;, &lt;nil&gt;s, err = strconv.Unquote(&quot;&apos;\u263a&apos;&quot;) // single character only allowed in single quotesfmt.Printf(&quot;%q, %v\n&quot;, s, err)// &quot;☺&quot;, &lt;nil&gt;s, err = strconv.Unquote(&quot;&apos;\u2639\u2639&apos;&quot;)fmt.Printf(&quot;%q, %v\n&quot;, s, err)// &quot;&quot;, invalid syntax strconv.UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)返回一个表示字符的语法字符串 s string，可以设置字符串定义语法 quote byte 双引号或者反引号。解析它并返回四个值：1234567891011v, mb, t, err := strconv.UnquoteChar(`\&quot;Fran &amp; Freddie&apos;s Diner\&quot;`, &apos;&quot;&apos;)if err != nil &#123; log.Fatal(err)&#125;fmt.Println(&quot;value:&quot;, string(v))// value: &quot;fmt.Println(&quot;multibyte:&quot;, mb)// multibyte: falsefmt.Println(&quot;tail:&quot;, t)// tail: Fran &amp; Freddie&apos;s Diner\&quot; 完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中多字节字符的处理]]></title>
    <url>%2Fgo%2Fgo-utf8%2F</url>
    <content type="text"><![CDATA[1 概述Go语言的字符串是使用 UTF-8 编码的。UTF-8 是 Unicode 的实现方式之一。本文内容包括：UTF-8 和 Unicode 的关系，Go语言提供的 unicode 包和 unicode/utf8 包的使用。 2 UTF-8 和 Unicode 的关系Unicode一种字符集，是国际标谁化组织（ISO）设计的一个包括了地球上所有文化、所有字母和符号 的编码。他们叫它 Universal Multiple-Octet Coded Character Set，简称 UCS，也就是 Unicode。Unicode 为每一个 字符 分配一个唯一的 码点（Code Point），就是一个唯一的值。例如 康 的码点就是 24247，十六进制为 5eb7。Unicode 字符集仅仅定义了字符与码点的对应关系，但是并没有定义该如何编码（存储）这个码值，这就导致了很多问题。例如由于字符的码值不同，导致所需要的存储空间是不一致的，计算机不能确定接下来的字符是占用几个字节。还有就是如果采用固定的长度假设都是4个字节来存储码点值，那么会导致空间的额外浪费，因为 ascii 码字符其实仅仅需要一个字节的空间。 UTF-8 就是解决如何为 Unicode 编码而设计的一种编码规则。可以说 UTF-8 是 Unicode 的实现方式之一。其特点是一种变长编码，使用1到4个字节表示一个字符，根据不同的符号而变化长度。UTF-8 的编码规则有二： 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于ASCII码字符，UTF-8 编码和 ASCII 码是相同的。 对于 n 字节的符号（n &gt; 1，2到4），第一个字节的前n位都设为1，第n + 1 位设为 0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 以下是编码规则：1234567Unicode | UTF-8--------------------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx--------------------------------------------------------- Go语言中，对于 Unicode 和 UTF-8 使用了 unicode 和 unicode/utf8 包来实现，下面是阅读 API 的总结和说明。 3 Unicode 包Go语言中，提供了 Unicode 包，处理与 Unicode 相关的操作，整理如下： Is(rangeTab *RangeTable, r rune) bool检测 rune r 是否在 rangeTable 指定的字符范围内。rangeTable 一个 Unicode 码值集合，通常使用 unicode 包中定义的集合。12345判断字符是否出现在汉字集合中：unicode.Is(unicode.Scripts[&quot;Han&quot;], &apos;k&apos;)// 返回 falseunicode.Is(unicode.Scripts[&quot;Han&quot;], &apos;康&apos;)// 返回 true In(r rune, ranges …*RangeTable) bool检测 rune r 是否在多个 rangeTable 指定的字符范围内。rangeTable 一个 Unicode 码值集合，通常使用 unicode 包中定义的集合。1234unicode.In(&apos;康&apos;, unicode.Scripts[&quot;Han&quot;], unicode.Scripts[&quot;Latin&quot;])// 返回 trueunicode.In(&apos;k&apos;, unicode.Scripts[&quot;Han&quot;], unicode.Scripts[&quot;Latin&quot;])// 返回 true IsOneOf(ranges []*RangeTable, r rune) bool检测 rune r 是否在 rangeTable ranges 指定的字符范围内。与 In 功能类似，推荐使用 In。 IsSpace(r rune) bool检测字符 rune r 是否是空白字符。在Latin-1字符空间中，空白字符为：1&apos;\t&apos;, &apos;\n&apos;, &apos;\v&apos;, &apos;\f&apos;, &apos;\r&apos;, &apos; &apos;, U+0085 (NEL), U+00A0 (NBSP) 其它的空白字符请参见策略Z和属性Pattern_White_Space。 IsDigit(r rune) bool检测字符 rune r 是否是十进制数字字符。1234unicode.IsDigit(&apos;9&apos;)// 返回 trueunicode.IsDigit(&apos;k&apos;)// 返回 false IsNumber(r rune) bool检测字符 rune r 是否是 Unicode 数字字符。 IsLetter(r rune) bool检测一个字符 rune r 是否是字母1234unicode.IsLetter(&apos;9&apos;)// 返回 falseunicode.IsLetter(&apos;k&apos;)// 返回 true IsGraphic(r rune) bool一个字符 rune r 是否是 unicode 图形字符。图形字符包括字母、标记、数字、符号、标点、空白。1234unicode.IsGraphic(&apos;9&apos;)// 返回 trueunicode.IsGraphic(&apos;,&apos;)// 返回 true IsControl(r rune) bool检测一个字符 rune r 是否是 unicode 控制字符。 IsMark(r rune) bool检测一个字符 rune r 是否是标记字符。 IsPrint(r rune) bool检测一个字符 rune r 是否是的可打印字符，基本与图形字符一致，除ASCII空白字符U+0020。 IsPunct(r rune) bool检测一个字符 rune r 是否是 unicode标点字符。1234unicode.IsPunct(&apos;9&apos;)// 返回 falseunicode.IsPunct(&apos;,&apos;)// 返回 true IsSymbol(r rune) bool检测一个字符 rune r 是否是 unicode 符号字符。 IsLower(r rune) bool检测一个字符 rune r 是否是小写字母。1234unicode.IsLower(&apos;h&apos;)// 返回 trueunicode.IsLower(&apos;H&apos;)// 返回 false IsUpper(r rune) bool检测一个字符 rune r 是否是大写字母。1234unicode.IsUpper(&apos;h&apos;)// 返回 falseunicode.IsUpper(&apos;H&apos;)// 返回 true IsTitle(r rune) bool检测一个字符 rune r 是否是Title字符。大部分字符的 Title 格式就是其大写格式，少数字符的 Title 格式是特殊字符，例如 ᾏᾟᾯ。123456unicode.IsTitle(&apos;ᾯ&apos;)// 返回 trueunicode.IsTitle(&apos;h&apos;)// 返回 falseunicode.IsTitle(&apos;H&apos;)// 返回 true To(_case int, r rune) rune将字符 rune r 转换为指定的格式，格式_case支持：unicode.UpperCase、unicode.LowerCase、unicode.TitleCase12unicode.To(unicode.UpperCase, &apos;h&apos;)// 返回 H ToLower(r rune) rune将字符 rune r 转换为小写。12unicode.ToLower(&apos;H&apos;)// 返回 h func (SpecialCase) ToLower将字符 rune r 转换为小写。优先使用映射表 SpecialCase。映射表 SpecialCase 是特定语言环境下大小写的映射表。主要应用于一些欧洲字符，例如土耳其 TurkishCase。12unicode.TurkishCase.ToLower(&apos;İ&apos;)// 返回 i ToUpper(r rune) rune将字符 rune r 转换为大写。12unicode.ToUpper(&apos;h&apos;)// 返回 H func (SpecialCase) ToUpper将字符 rune r 转换为大写。优先使用映射表 SpecialCase。映射表 SpecialCase 是特定语言环境下大小写的映射表。主要应用于一些欧洲字符，例如土耳其 TurkishCase。12unicode.TurkishCase.ToUpper(&apos;i&apos;)// 返回 İ ToTitle(r rune) rune将字符 rune r 转换为 Title 字符。12unicode.ToTitle(&apos;h&apos;)// 返回 H func (SpecialCase) ToTitle将字符 rune r 转换为 Title 字符。优先使用映射表 SpecialCase。映射表 SpecialCase 是特定语言环境下大小写的映射表。主要应用于一些欧洲字符，例如土耳其 TurkishCase。12unicode.TurkishCase.ToTitle(&apos;i&apos;)// 返回 İ SimpleFold(r rune) rune在 unicode 标准字符映射中查找与 rune r 互相对应的 unicode 码值。向码值大的方向循环查找。互相对应指的是同一个字符可能出现的多种写法。1234unicode.SimpleFold(&apos;H&apos;)// 返回 hunicode.SimpleFold(&apos;Φ&apos;)) // 返回 φ 4 unicode/utf8 包DecodeLastRune(p []byte) (r rune, size int)解码 []byte p 中最后一个 UTF-8 编码序列，返回该码值和长度。123utf8.DecodeLastRune([]byte(&quot;小韩说课&quot;))// 返回 35838 3// 35838 就是课的 unicode 码值 DecodeLastRuneInString(s string) (r rune, size int)解码 string s 中最后一个 UTF-8 编码序列，返回该码值和长度。123utf8.DecodeLastRuneInString(&quot;小韩说课&quot;)// 返回 35838 3// 35838 就是课的 unicode 码值 DecodeRune(p []byte) (r rune, size int)解码 []byte p 中第一个 UTF-8 编码序列，返回该码值和长度。123utf8.DecodeRune([]byte(&quot;小韩说课&quot;))// 返回 23567 3// 23567 就是 小 的 unicode 码值 DecodeRuneInString(s string) (r rune, size int)解码 string s 中第一个 UTF-8 编码序列，返回该码值和长度。123utf8.DecodeRuneInString(&quot;小韩说课&quot;)// 返回 23567 3// 23567 就是 小 的 unicode 码值 EncodeRune(p []byte, r rune) int将 rune r 的 UTF-8 编码序列写入 []byte p，并返回写入的字节数。p 满足足够的长度。1234buf := make([]byte, 3)n := utf8.EncodeRune(buf, &apos;康&apos;)fmt.Println(buf, n)// 输出 [229 186 183] 3 FullRune(p []byte) bool检测 []byte p 是否包含一个完整 UTF-8 编码。12345buf := []byte&#123;229, 186, 183&#125; // 康utf8.FullRune(buf)// 返回 trueutf8.FullRune(buf[:2])// 返回 false FullRuneInString(s string) bool检测 string s 是否包含一个完整 UTF-8 编码。12345buf := &quot;康&quot; // 康utf8.FullRuneInString(buf)// 返回 trueutf8.FullRuneInString(buf[:2])// 返回 false RuneCount(p []byte) int返回 []byte p 中的 UTF-8 编码的码值的个数。12345buf := []byte(&quot;小韩说课&quot;)len(buf)// 返回 12utf8.RuneCount(buf)// 返回 4 RuneCountInString(s string) (n int)返回 string s 中的 UTF-8 编码的码值的个数。12345buf := &quot;小韩说课&quot;len(buf)// 返回 12utf8.RuneCountInString(buf)// 返回 4 RuneLen(r rune) int返回 rune r 编码后的字节数。1234utf8.RuneLen(&apos;康&apos;)// 返回 3utf8.RuneLen(&apos;H&apos;)// 返回 1 RuneStart(b byte) bool检测字节 byte b 是否可以作为某个 rune 编码的第一个字节。1234567buf := &quot;小韩说课&quot;utf8.RuneStart(buf[0])// 返回 trueutf8.RuneStart(buf[1])// 返回 falseutf8.RuneStart(buf[3])// 返回 true Valid(p []byte) bool检测切片 []byte p 是否包含完整且合法的 UTF-8 编码序列。123456valid := []byte(&quot;小韩说课&quot;)invalid := []byte&#123;0xff, 0xfe, 0xfd&#125;utf8.Valid(valid)// 返回 trueutf8.Valid(invalid)// 返回 false ValidRune(r rune) bool检测字符 rune r 是否包含完整且合法的 UTF-8 编码序列。123456valid := &apos;a&apos;invalid := rune(0xfffffff)fmt.Println(utf8.ValidRune(valid))// 返回 truefmt.Println(utf8.ValidRune(invalid))// 返回 false ValidString(s string) bool检测字符串 string s 是否包含完整且合法的 UTF-8 编码序列。123456valid := &quot;小韩说课&quot;invalid := string([]byte&#123;0xff, 0xfe, 0xfd&#125;)fmt.Println(utf8.ValidString(valid))// 返回 truefmt.Println(utf8.ValidString(invalid))// 返回 false 完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的字符串处理]]></title>
    <url>%2Fgo%2Fgo-string%2F</url>
    <content type="text"><![CDATA[1 概述 2 常规操作 []索引访问 unicode/utf8 包 len()，字符串占用的字节数 +，字符串连接” ==, &gt;, &lt; strings.Compare(a, b string) int strings.Contains(s, substr string) bool strings.ContainsAny(s, chars string) bool strings.ContainsRune(s string, r rune) bool strings.Count(s, substr string) int strings.EqualFold(s, t string) bool strings.Fields(s string) []string strings.FieldsFunc(s string, f func(rune) bool) []string strings.HasPrefix(s, prefix string) bool strings.HasSuffix(s, suffix string) bool strings.Index(s, substr string) int strings.IndexAny(s, chars string) int strings.IndexByte(s string, c byte) int strings.IndexFunc(s string, f func(rune) bool) int strings.IndexRune(s string, r rune) int strings.Join(a []string, sep string) string strings.LastIndex(s, substr string) int strings.LastIndexAny(s, chars string) int strings.LastIndexByte(s string, c byte) int strings.LastIndexFunc(s string, f func(rune) bool) int strings.Map(mapping func(rune) rune, s string) string strings.Repeat(s string, count int) string strings.Replace(s, old, new string, n int) string strings.Split(s, sep string) []string strings.SplitAfter(s, sep string) []string strings.SplitAfterN(s, sep string, n int) []string strings.SplitN(s, sep string, n int) []string strings.Title(s string) string strings.ToLower(s string) string strings.ToLowerSpecial(c unicode.SpecialCase, s string) string strings.ToTitle(s string) string strings.ToTitleSpecial(c unicode.SpecialCase, s string) string strings.ToUpper(s string) string strings.ToUpperSpecial(c unicode.SpecialCase, s string) string strings.Trim(s string, cutset string) string strings.TrimFunc(s string, f func(rune) bool) string strings.TrimLeft(s string, cutset string) string strings.TrimLeftFunc(s string, f func(rune) bool) string strings.TrimPrefix(s, prefix string) string strings.TrimRight(s string, cutset string) string strings.TrimRightFunc(s string, f func(rune) bool) string strings.TrimSpace(s string) string strings.TrimSuffix(s, suffix string) string 1 概述字符串，string，一串固定长度的字符连接起来的字符集合。Go语言的字符串是使用UTF-8编码的。UTF-8是Unicode的实现方式之一。 Go语言原生支持字符串。使用双引号(“”)或反引号(``)定义。双引号：””, 用于单行字符串。反引号：``，用于定义多行字符串，内部会原样解析。示例：123456789// 单行&quot;心有猛虎，细嗅蔷薇&quot;// 多行`大风歌大风起兮云飞扬。威加海内兮归故乡。安得猛士兮守四方！` 字符串支持转义字符，列表如下： \r 回车符（返回行首） \n 换行符（直接跳到下一行的同列位置） \t 制表符 \’ 单引号 \” 双引号 \\ 反斜杠 \uXXXX Unicode字符码值转义，例如 &quot;\u5eb7&quot; 就是 “康” Go语言中字符串的顶层结构是由一个指针和长度构成的。使用 unsafe.Sizeof(“”) 会得到16长度，其中8个字节是指针，指向字符串的内存地址，8个是存储字符串的长度。 2 常规操作以下是针对字符串的操作总结，主要来自于Go语言的API的说明和测试。 []索引访问可以使用[index]方式，访问到字符串中的字符。可以访问，不可以修改。123s := &quot;Hank&quot;fmt.Printf(&quot;%c&quot;, s[2])// 返回 n unicode/utf8 包多字节字符的处理，请参考 unicode/utf8 包的相关说明。例如：123import &quot;unicode/utf8&quot;utf8.RuneCountInString(&quot;小韩说课&quot;)// 返回 4 len()，字符串占用的字节数utf-8 是变长字符集，英文标点占用1个字节，中文占用3个字节。12len(&quot;Hank康&quot;) // 返回 7 +，字符串连接”1&quot;Hello&quot; + &quot; &quot; + &quot;Hank&quot; ==, &gt;, &lt;字符串比较，比较机制是字符的对称比较。12&quot;abc&quot; &gt; &quot;bbcd&quot;// 结果为false strings.Compare(a, b string) int字符串比较，比较机制是字符的对称比较。返回值为： 0，表示a == b -1，表示a &lt; b 1，表示a &gt; b 12strings.Compare(&quot;abc&quot;, &quot;abcd&quot;)// 返回 1 strings.Contains(s, substr string) bool检测字符串 substr 是否在 s 中。1234strings.Contains(&quot;foobar&quot;, &quot;foo&quot;)// 返回 truestrings.Contains(&quot;fobar&quot;, &quot;foo&quot;)// 返回 false strings.ContainsAny(s, chars string) bool检测字符串 chars 的中任意字符是否出现在 s 中。1234fmt.Println(strings.ContainsAny(&quot;Hank&quot;, &quot;kang&quot;)) // 返回 truefmt.Println(strings.ContainsAny(&quot;Hank&quot;, &quot;go&quot;)) // 返回 false strings.ContainsRune(s string, r rune) bool检测 rune字符是否出现在 s 中。1234strings.ContainsRune(&quot;Hank&quot;, &apos;a&apos;)// 返回 truestrings.ContainsRune(&quot;Hank&quot;, 97)// 返回 true，a的码值97 strings.Count(s, substr string) int统计字符串 s 中非重叠substr的数量。若统计空字符串””，会返回 s 的长度加1。1234strings.Count(&quot;HanZhongKang&quot;, &quot;n&quot;)// 返回 3strings.Count(&quot;Hank&quot;, &quot;&quot;)// 返回 5，&quot;Hank&quot;每个rune的前后都算 strings.EqualFold(s, t string) bool检测字符串 s 和 t 在忽略大小写的情况下是否相等。12strings.EqualFold(&quot;Hank&quot;, &quot;hank&quot;)// 返回 true strings.Fields(s string) []string返回使用空格分割的字符串 s，结果为切片。12strings.Fields(&quot;Han Zhong Kang&quot;)// 返回 []string, [&quot;Han&quot;, &quot;Zhong&quot;, &quot;Kang&quot;] strings.FieldsFunc(s string, f func(rune) bool) []string使用函数确定分隔符，来分割字符串 s。结果是切片。123456// ,|/ 都是分隔符fn := func(c rune) bool &#123; return strings.ContainsRune(&quot;,|/&quot;, c)&#125;strings.FieldsFunc(&quot;go,python,c++/c,Js|JavaScript&quot;, fn)// 返回 [&quot;go&quot; &quot;python&quot; &quot;c++&quot; &quot;c&quot; &quot;Js&quot; &quot;JavaScript&quot;] strings.HasPrefix(s, prefix string) bool检测字符串 s 是否以字符串 prefix 作为前缀。12strings.HasPrefix(&quot;Gopher&quot;, &quot;Go&quot;)// 返回 true strings.HasSuffix(s, suffix string) bool检测字符串 s 是否以字符串 suffix 作为后缀。12strings.HasSuffix(&quot;Gopher&quot;, &quot;er&quot;)// 返回 true strings.Index(s, substr string) int返回字符串 substr 在字符串 s 中第一次出现的索引位置，若没有出现，返回-1。12strings.Index(&quot;Gopher&quot;, &quot;ph&quot;)// 返回 2 strings.IndexAny(s, chars string) int返回字符串 chars 中的任意字符在字符串 s 中第一次出现的索引位置，若没有出现，返回-1。12strings.IndexAny(&quot;Gopher&quot;, &quot;lmno&quot;)// 返回 1 strings.IndexByte(s string, c byte) int返回byte字符 c 在字符串 s 中第一次出现的索引位置，若没有出现，返回-1。12strings.IndexByte(&quot;Gopher&quot;, &apos;h&apos;)// 返回 3 strings.IndexFunc(s string, f func(rune) bool) int返回字符串 s 中第一次满足函数 f 的rune字符的索引位置，若没有出现，返回-1。12345fn := func(c rune) bool &#123; return strings.ContainsRune(&quot;,|/&quot;, c)&#125;strings.IndexFunc(&quot;go,python,c++/c,Js|JavaScript&quot;, fn)// 返回 2 strings.IndexRune(s string, r rune) int返回run字符 r 在字符串 s 中第一次出现的索引位置，若没有出现，返回-1。12strings.IndexRune(&quot;小韩说课&quot;, &apos;说&apos;)// 返回 6 strings.Join(a []string, sep string) string使用分隔符 sep 连接字符串切片 a。123ss := []string&#123;&quot;Go&quot;, &quot;Hank&quot;, &quot;Python&quot;, &quot;PHP&quot;&#125;strings.Join(ss, &quot;-&quot;)// 返回 &quot;Go-Hank-Python-PHP&quot; strings.LastIndex(s, substr string) int返回字符串 substr 在字符串 s 中最后一次出现的索引位置，若没有出现，返回-1。12strings.LastIndex(&quot;Hankang&quot;, &quot;an&quot;)// 返回 4 strings.LastIndexAny(s, chars string) int返回字符串 chars 中的任意字符在字符串 s 中最后一次出现的索引位置，若没有出现，返回-1。12strings.LastIndexAny(&quot;Hankang&quot;, &quot;lmno&quot;)// 返回 5 strings.LastIndexByte(s string, c byte) int返回byte字符 c 在字符串 s 中最后一次出现的索引位置，若没有出现，返回-1。12strings.LastIndexByte(&quot;Hankang&quot;, &apos;n&apos;)// 返回 5 strings.LastIndexFunc(s string, f func(rune) bool) int返回字符串 s 中字后一次满足函数 f 的rune字符的索引位置，若没有出现，返回-1。12345fn := func(c rune) bool &#123; return strings.ContainsRune(&quot;,|/&quot;, c)&#125;strings.LastIndexFunc(&quot;go,Js|JavaScript&quot;, fn)// 返回 5 strings.Map(mapping func(rune) rune, s string) string返回字符串 s 中的每个字符经过映射函数 mapping 处理之后的字符串。123456789fn := func(c rune) rune &#123; if strings.ContainsRune(&quot;,|/&quot;, c) &#123; return &apos;-&apos; &#125; else &#123; return c &#125;&#125;strings.Map(fn, &quot;go,Js|JavaScript&quot;)// 返回 &quot;go-Js-JavaScript&quot; strings.Repeat(s string, count int) string返回将字符串 s 重复 count 的字符串。12strings.Repeat(&quot;la~&quot;, 3)// 返回值 &quot;la~la~la~&quot; strings.Replace(s, old, new string, n int) string在字符串 s 中使用字符串 new 替换字符串 old，使用 n 限定替换次数，n设置为负数表示没有限制。返回替换结果。12strings.Replace(&quot;han zhong kang&quot;, &quot;n&quot;, &quot;N&quot;, 2)// 返回 &quot;haN zhoNg kang&quot; strings.Split(s, sep string) []string使用分隔符 sep 分割字符串 s，返回字符串切片12strings.Split(&quot;go-Js-JavaScript&quot;, &quot;-&quot;)// 返回 [&quot;go&quot;, &quot;Js&quot;, &quot;JavaScript&quot;] strings.SplitAfter(s, sep string) []string在分隔符 sep 后分割字符串 s，返回字符串切片12strings.SplitAfter(&quot;go-Js-JavaScript&quot;, &quot;-&quot;)// 返回 [&quot;go-&quot;, &quot;Js-&quot;, &quot;JavaScript&quot;] strings.SplitAfterN(s, sep string, n int) []string在分隔符 sep 后分割字符串 s，使用 n 限定分割的元素数量，n&lt;0全部子字符串，n&gt;0最后一个子字符串包含余下内容，n==0返回nil。返回子字符串切片。12strings.SplitAfterN(&quot;go-Js-JavaScript&quot;, &quot;-&quot;, 2)// 返回 [&quot;go-&quot;, &quot;Js-JavaScript&quot;] strings.SplitN(s, sep string, n int) []string在分隔符 sep 分割字符串 s，使用 n 限定分割的元素数量，n&lt;0全部子字符串，n&gt;0最后一个子字符串包含余下内容，n==0返回nil。返回子字符串切片。12strings.SplitN(&quot;go-Js-JavaScript&quot;, &quot;-&quot;, 2)// 返回 [&quot;go&quot;, &quot;Js-JavaScript&quot;] strings.Title(s string) string返回Title化的字符串。12strings.Title(&quot;hello Hank&apos;s go&quot;)// 返回 &quot;Hello Hank&apos;s Go&quot; strings.ToLower(s string) string转换字符串 s 到小写。12strings.ToLower(&quot;Hank&apos;s Go Guide&quot;)// 返回 &quot;hank&apos;s go guide&quot; strings.ToLowerSpecial(c unicode.SpecialCase, s string) string使用特定的规则转换字符串 s 到小写。12strings.ToLowerSpecial(unicode.TurkishCase, &quot;Önnek İş&quot;)// 返回 önnek iş strings.ToTitle(s string) string返回全部字符都Title化的字符串。12strings.Title(&quot;hello Hank&apos;s go&quot;)// 返回 &quot;HELLO HANK&apos;S GO&quot; strings.ToTitleSpecial(c unicode.SpecialCase, s string) string使用特定的规则将全部字符都Title化。12strings.ToTitleSpecial(unicode.TurkishCase, &quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&quot;)// 返回 &quot;DÜNYANIN İLK BORSA YAPISI AİZONAİ KABUL EDİLİR&quot; strings.ToUpper(s string) string将字符串 s 中所有字符转换为大写。12strings.ToUpper(&quot;hello Hank&apos;s go&quot;)// 返回 &quot;HELLO HANK&apos;S GO&quot; strings.ToUpperSpecial(c unicode.SpecialCase, s string) string使用特定的规则将字符串 s 中所有字符转换为大写。12strings.ToUpperSpecial(unicode.TurkishCase, &quot;örnek iş&quot;)// 返回 &quot;ÖRNEK İŞ&quot; strings.Trim(s string, cutset string) string截取字符串 s 两端包裹的特定字符集 cutset。12strings.Trim(&quot; user name &quot;, &quot; &quot;)// 返回 &quot;user name&quot; strings.TrimFunc(s string, f func(rune) bool) string截取字符串 s 两端满足函数 f 的字符。12345fn := func(c rune) bool &#123; return strings.ContainsRune(&quot;,|/&quot;, c)&#125;strings.TrimFunc(&quot;|/user name,/&quot;, fn)// 返回 &quot;user name&quot; strings.TrimLeft(s string, cutset string) string截取字符串 s 左边包裹的特定字符集 cutset。12strings.TrimLeft(&quot; user name &quot;, &quot; &quot;)// 返回 &quot;user name &quot; strings.TrimLeftFunc(s string, f func(rune) bool) string截取字符串 s 左边满足函数 f 的字符。12345fn := func(c rune) bool &#123; return strings.ContainsRune(&quot;,|/&quot;, c)&#125;strings.TrimLeftFunc(&quot;|/user name,/&quot;, fn)// 返回 &quot;user name,/&quot; strings.TrimPrefix(s, prefix string) string截取字符串 s 的前缀 prefix。12strings.TrimPrefix(&quot;hank_goGuide&quot;, &quot;hank_&quot;)// 返回 &quot;goGuide&quot; strings.TrimRight(s string, cutset string) string截取字符串 s 右边包裹的特定字符集 cutset。12strings.TrimRight(&quot; user name &quot;, &quot; &quot;)// 返回 &quot; user name&quot; strings.TrimRightFunc(s string, f func(rune) bool) string截取字符串 s 右边满足函数 f 的字符。12345fn := func(c rune) bool &#123; return strings.ContainsRune(&quot;,|/&quot;, c)&#125;strings.TrimRightFunc(&quot;|/user name,/&quot;, fn)// 返回 &quot;|/user name&quot; strings.TrimSpace(s string) string截取字符串 s 两端的空白字符。12strings.TrimSpace(&quot; \t\n Hello, Gophers \n\t\r\n&quot;)// 返回 &quot;Hello, Gophers&quot; strings.TrimSuffix(s, suffix string) string截取字符串 s 的后缀 suffix。12strings.TrimSuffix(&quot;goGuide_beta&quot;, &quot;_beta&quot;)// 返回 &quot;goGuide&quot; 完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言的包管理]]></title>
    <url>%2Fgo%2Fgo-package%2F</url>
    <content type="text"><![CDATA[1 概述 2 main包 3 包定义，package 4 导入包，import 4 GOPATH环境变量 5 init() 包初始化 1 概述Go 语言的源码复用建立在包（package）基础之上。包通过 package, import, GOPATH 操作完成。 2 main包Go 语言的入口 main() 函数所在的包（package）叫 main，main 包想要引用别的代码，需要import导入！ 3 包定义，packageGo 语言的包与文件夹一一对应，同一个目录下的所有.go文件的第一行添加 包定义，以标记该文件归属的包，演示语法：1package 包名 包需要满足： 一个目录下的同级文件归属一个包。 包名可以与其目录不同名。 包名为 main 的包为应用程序的入口包，其他包不能使用。 包可以嵌套定义，对应的就是嵌套目录，但包名应该与所在的目录一致，例如：12345678// 文件：foo/bar/tool.go中package bar// 可以被导出的函数func FuncPublic() &#123;&#125;// 不可以被导出的函数func funcPrivate() &#123;&#125; 包中，通过标识符首字母是否大写，来确定是否可以被导出。首字母大写才可以被导出，视为 public 公共的资源。 4 导入包，import要引用其他包，可以使用 import 关键字，可以单个导入或者批量导入，语法演示：1234567// 单个导入import &quot;package&quot;// 批量导入import ( &quot;package1&quot; &quot;package2&quot; ) 导入时，可以为包定义别名，语法演示：123456import ( p1 &quot;package1&quot; p2 &quot;package2&quot; )// 使用时p1.Method() 以上测试请使用系统包测试。若需要导入自定义包，需要设置GOPATH环境变量。 4 GOPATH环境变量import导入时，会从GO的安装目录（也就是GOROOT环境变量设置的目录）和GOPATH环境变量设置的目录中，检索 src/package 来导入包。如果不存在，则导入失败。GOROOT，就是GO内置的包所在的位置。GOPATH，就是我们自己定义的包的位置。 通常我们在开发Go项目时，调试或者编译构建时，需要设置GOPATH指向我们的项目目录，目录中的src目录中的包就可以被导入了：例如，我么的项目目录为： D:\projects\goProject，那么我么就需要将我们的源代码放在 D:\projects\goProject\src 下，同时设置GOPATH为 D:\projects\goProject。设置GOPATH的方案有： windows 通过 系统-&gt;系统信息-&gt;高级系统设置-&gt;环境变量 中完成设置。 windows 中通过 CMD 或者 powershell 也可以完成设置。通常是临时有效的，CMD或者powershell关闭失效！ 123456CMD：set GOPATH=D:\projects\goProjectset GOPATH 可以查看powershell：$env:GOPATH=&quot;D:\projects\goProject&quot;$env:GOPATH 可以查看 linux 通过 /etc/profile 进行设置 5 init() 包初始化可以在源码中，定义 init() 函数。此函数会在包被导入时执行，例如如果是在 main 中导入包，包中存在 init()，那么 init() 中的代码会在 main() 函数执行前执行，用于初始化包所需要的特定资料。例如：包源码：1234567src/userPackage/tool.gopackage userPackageimport &quot;fmt&quot;func init() &#123; fmt.Println(&quot;tool init&quot;)&#125; 主函数源码：1234567891011src/main.gopackage mainimport ( &quot;userPackage&quot; )func main() &#123; fmt.Println(&quot;main run&quot;) // 使用userPackage userPackage.SomeFunc()&#125; 执行时，会先输出 “tool init”，再输出 “main run”。 如果仅仅需要导入包时执行初始化操作，并不需要使用包内的其他函数，常量等资源。则可以在导入包时，匿名导入：123import ( _ &quot;userPackage&quot; ) 使用下划线作为包的别名，会仅仅执行init() 完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的函数]]></title>
    <url>%2Fgo%2Fgo-function%2F</url>
    <content type="text"><![CDATA[1 概述函数，function，独立的，用于实现具体功能的代码块。主要目的，是代码的重用（重复使用），更好的管理代码，模块化开发。函数通常使用参数和返回值，与调用者交互数据。参数给函数传递数据，返回值，函数将处理好的数据传递给调用者。Go语言中函数被称为一等公民（first-class）。意味着支持高阶函数，支持匿名函数，支持闭包等特性，可以满足接口等高级函数特性。 2 定义语法：123456定义：func 函数名(形参列表)(返回值类型列表) &#123; 函数体，通常会有return语句，返回值&#125;调用：函数名(实参列表) 函数名：函数的标识符，用于找到函数，内部是一个指向函数代码的地址。形参列表：由变量和类型构成返回值类型列表：函数返回值的类型，多个返回值需要指定多个。函数体：实现函数功能的具体语句。return语句：返回值语句 以上定的为命名函数，不能定义在其他函数内部。 3 参数用于在调用函数时向函数传递数据。实参，实际参数。调用时给的参数。指的是具有的特定实际数据的参数。形参，形式参数。定义时使用的参数。指的是用来表示函数需要参数，而定义时参数是没有任实际何数据的。当调用时会发生使用实参为形参变量赋值的过程，称为参数的传递。在函数的执行期间，形参是有具体数据的，形参当于函数内声明的变量。 参数的传递，分为值传递，地址传递两种方式。地址传递时，需要形参定义为指针类型，调用时需要取得地址传参。示例代码：1234567891011121314151617func funcTest(p1 int, p2 *int) &#123; p1++ *p2++ fmt.Println(p1, *p2)&#125;func main() &#123; var ( a1 = 42 a2 = 42 ) funcTest(a1, &amp;a2) // 参数赋值过程 fmt.Println(a1, a2)&#125;以上会输出43 4342 43 值传递，函数会得到实参的一份拷贝。地址传递，函数会得到实参地址，这样函数内通过地址对变量的修改，同时影响实参。 Go支持rest…不定数量参数，定义时将不定数量形参放在形参列表的最后定义，使用 …Type的方式，演示：123456定义：func funcTest(op string, nums ...int) &#123; fmt.Println(nums) // [4, 1, 55, 12], slice切片型数据&#125;调用funcTest(&quot;someOp&quot;, 4, 1, 55, 12) 接收到的参数为slice切片类型。 4 返回值return语句用于生成返回值。需要在函数定义时确定返回值类型，支持多值返回。演示语法：123func funcTest() (int, string) &#123; return 42, &quot;Hank&quot;&#125; 可以在定义时，声明返回的变量。这个做法叫命名返回，演示为：12345func funcTest() (num int, title string) &#123; num = 42 title = &quot;Hank&quot; return&#125; 不用return任何数据，直接return即可！ 5 函数变量函数可以看作一种特殊的指针类型，可以和其他类型一样被保存在变量中。通过函数标识符和变量都可以访问到该函数，演示如下：123456789101112131415func funcTest() &#123; fmt.Println(&quot;func() type&quot;)&#125;func main() &#123; fmt.Printf(&quot;%T, (%v)\n&quot;, funcTest, funcTest) fn := funcTest fmt.Printf(&quot;%T, (%v)\n&quot;, fn, fn) funcTest() fn()&#125;执行结果：func(), (0x48fe20)func(), (0x48fe20)func() typefunc() type 可见，函数标识符就是指向函数的指针。可以赋值给其他变量。 6 函数参数函数也可以作为其他函数的参数来使用，演示如下：12345678func funcSuccess() &#123;&#125;func funcAsync(handle func()) &#123; // 调用函数参数 handle()&#125;// 传递函数到其他函数funcAsync(success) 这种回调函数的使用语法，在处理异步逻辑时十分有用。 7 匿名函数可以定义匿名函数。可以将匿名函数保存到变量中，作为参数传递，或者立即调用。如果函数时临时使用函数，则匿名函数是一个好选择。示例语法：123456789101112赋值给变量fn := func() &#123;&#125;fn()// 作为参数someFunc(func() &#123; &#125;)// 立即调用func() &#123; &#125;() 8 闭包由于匿名函数可以定义在其他函数内，同时变量的作用域为层叠的，也就是匿名函数可以会访问其所在的外层函数内的局部变量。当外层函数运行结束后，匿名函数会与其使用的外部函数的局部变量形成闭包。示例代码：1234567891011var fn func()func outer() &#123; v := 42 fn = func() &#123; v ++ fmt.Print(v) &#125;&#125;outer()fn() // 43 此例中，fn 对应的匿名函数与 outer() 的局部变量 v，就形成了闭包。 9 函数调用示意图123456789var v = &quot;global&quot;func funcTest(v) &#123; v = &quot;funcTest&quot; fmt.Println(v)&#125;func main() &#123; v := &quot;main&quot; funcTest(v)&#125; 代码编译期间，会将函数代码存放在内存代码区。函数被调用时，在运行期间会在函数运行栈区开辟函数栈，内部由局部变量标识符列表（就是局部变量），上层标识符列表引用等信息。直到运行结束，此空间才会被出栈，释放。函数内部调用了新函数，新函数的执行空间入栈，要等到新函数执行空间出栈，调用他的函数才会被出栈。以上代码的运行逻辑图如下： 10 递归调用函数内部调用函数本身。称之为递归调用。示例代码：1234func funcTest() &#123; fmt.Println(&quot;run&quot;) funcTest()&#125; 定义实现递归调用函数时，通常需要定义一个出口。用来确定何时不再进行递归调用了。一旦满足条件，则调用停止。例如：1234567func funcTest(v) &#123; fmt.Println(v, &quot;run&quot;) v ++ if v &lt;= 10 &#123; funcTest() &#125;&#125; 典型的应用有，树状菜单的处理，遍历目录，快速排序等。递归调用的优势是编码简单，与描述的业务逻辑保持一致。 完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的流程控制]]></title>
    <url>%2Fgo%2Fgo-flow-control%2F</url>
    <content type="text"><![CDATA[1 概述 2 条件分支 if 3 状态分支 switch 3.1 基础 3.2 fallthrough，向下穿越 3.3 条件型 switch 4 循环for 4.1 基本 4.2 省略语句 4.3 break 4.4 continue 4.5 嵌套循环 5 goto 6 延迟执行defer 1 概述Go语言提供了条件分支 if，状态分支 switch，循环 for，跳转 goto，延迟执行 defer，这些流程控制语句。分别作说明如下： 2 条件分支 if依据条件是否满足确定执行哪个分支。语法：123456789if 条件 1 &#123; 分支 1&#125; else if 条件 2 &#123; 分支 2&#125; else if 条件 ... &#123; 分支 ...&#125; else &#123; 分支 else&#125; 流程图： Go是强类型，要求条件表达式严格返回布尔型数据！ 3 状态分支 switch3.1 基础状态分支，依据特定的状态值进行分支判断。语法：12345678910switch 分支测试表达式 &#123;case 状态1: 分支1case 状态2: 分支2case 状态...: 分支...default: 分支 default&#125; 流程如下： 3.2 fallthrough，向下穿越在其他语法（非Go，C，PHP）中，switch 有一个特定的现象，就是向下穿越，指的是一旦一个分支 case 满足，则后续分支代码都会被执行。而Go语言中，默认分支执行完毕，switch 执行完毕。使用 fallthrough 语法，可以达到穿越下一个 case 分支的目的。fallthrough 需要出现在分支语句块的最后一句！语法：12345678910switch 分支测试表达式 &#123;case 状态1: 分支1 fallthroughcase 状态2: 分支2 fallthroughdefault: 分支 default&#125; 流程如下： 3.3 条件型 switch示例代码，逻辑与 if-else-if 一致：123456789score := 89switch &#123;case score &gt;= 90: fmt.Println(&quot;优秀，不错&quot;)case score &gt;= 80: fmt.Println(&quot;还行吧&quot;)default: fmt.Println(&quot;呵呵&quot;)&#125; 个人感觉失去了 switch 分支的意义哈！ 4 循环for4.1 基本语法格式：12345678for 初始化语句; 条件语句; 条件变化语句 &#123; 循环体&#125;// 输出1-10for i := 1; i &lt;= 10; i++ &#123; fmt.Println(i)&#125; 流程如下： 4.2 省略语句Go中允许省略三个语句中的任意，就是可以形成如下的语法：仅存在条件语句，类似其他语言的 while 结构！123for 条件语句 &#123; 循环体&#125; 无限循环结构，死循环123for &#123; 循环体&#125; 其他结构，三个语句可以任意省略，不再列举：123456for ; 条件语句; 条件变化语句 &#123; 循环体&#125;for 初始化语句; 条件语句; &#123; 循环体&#125; 4.3 break终止整个循环执行。流程图如下： 4.4 continue终止本次循环体的继续执行，进行循环条件变化。流程如下： 4.5 嵌套循环语法：12345for &#123; for &#123; &#125;&#125; 在使用 break，continue 时，若需要终止外层循环 for，需要配合语句标签使用，演示如下：12345678userLabel:for &#123; for &#123; break userLabel 或者 continue userLabel &#125;&#125; 额外注意，switch 在语言中，被视为执行一次的循环结构，因此 switch 中若要终止外层循环，需要使用标签语法，不能直接 break、continue，演示如下：123456789userLabel:for &#123; swtich variable &#123; case &quot;exit&quot; break userLabel 或者 continue userLabel &#125;&#125; 5 goto配合标签完成无条件跳转。演示如下：12345678if error &#123; goto doError&#125;// 其他业务逻辑代码略doError:fmt.Println(errorInfo) 6 延迟执行deferdefer 语句会将其后语句进行延迟处理。在 defer 所属函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。演示如下：12345678910111213 func main() &#123; fmt.Println(&quot;before defer&quot;) defer fmt.Println(&quot;defer A&quot;) defer fmt.Println(&quot;defer B&quot;) defer fmt.Println(&quot;defer C&quot;) fmt.Println(&quot;after defer&quot;)&#125;以上代码的执行结果：before deferafter deferdefer Cdefer Bdefer A defer 执行是放在一个临时的调用栈中，因此是先入栈后出栈的。流程图如下： 实操时，处理互斥所时，很常用！ 完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的运算符]]></title>
    <url>%2Fgo%2Fgo-operator%2F</url>
    <content type="text"><![CDATA[1 概述 2 算术运算 3 字符串连接运算 + 4 关系运算 5 逻辑运算 6 指针运算 7 位运算 8 赋值运算 9 运算符优先级 10 类型转换 1 概述Go语言提供了，算术，关系，逻辑，位，指针，赋值运算符。本篇整体说明一下。 2 算术运算 + 相加 - 相减 * 相乘 / 相除 % 求余 ++ 自增 -- 自减 几个细节，需要留意一下。 整数与浮点数进行运算，会将整数转化为浮点数，再运算。 两个整数相除，结果是整数，取整数部分。5/3 结果会是 1。 求余，如果被除数或除数存在负数，那么余数与被除数保持一致。此处是求余不是取模。 ++/–，不区分前后，只有变量后的语法，就是 v++。同时++/–构成语句而不是表达式，意味着不能直接赋值。 3 字符串连接运算 ++运算符，也可以完成字符串的连接运算。1&quot;Hello&quot; + &quot; &quot; + &quot;Hank!&quot; 4 关系运算 == 检查两个值是否相等 != 检查两个值是否不相等 > 检查左边值是否大于右边值 &lt; 检查左边值是否小于右边值 >= 检查左边值是否大于等于右边值 &lt;= 检查左边值是否小于等于右边值 关系运算时用于判断两个运算数的关系是否成立。返回布尔值。 5 逻辑运算 &amp;&amp; 逻辑与，参与运算的两个关系必须同时成立，结果为true，否则为false || 逻辑或，参与运算的两个关系成立一个（或都成立）结果为true，全部关系为false，结果为false。 ! 逻辑非，用于取反某个关系。非真既假，非假既真。只有一个运算数参与运算 用来判断多个关系是否成立。运算结果为：&amp;&amp;true &amp;&amp; true = truetrue &amp;&amp; false = falsefalse &amp;&amp; true = falsefalse &amp;&amp; false = false||true || true = truetrue || false = truefalse || true = truefalse || false = false!!true = false!false = true 6 指针运算 &amp; 取得变量的内存地址。pv := &amp;v * 获取指针地址对应的值。*pv示例为：123456v:=42pv:=&amp;vfmt.Printf(&quot;%T(%v)&quot;, pv, pv)// *int 0xc000048b68，*int就是指针类型 值为一个类似规则的地址，就是一个号码，标识内存的一个空间区域fmt.Println(*pv)// 42，通过地址获取对应的变量值*pv ++ // 通过地址更改对应变量fmt.Println(*pv, v)// 42 42变量和指针操作的同一变量（内存地址）。 Go语言的指针不可以操作。不能执行偏移这类的操作. 理解指针的几个概念：变量：标识符与值（内存中存储空间）引用。地址：内存中存储空间的位置（门牌号）指针：一种类型，其值为某个地址。 一个数据（变量），我们可以通过变量标识符找到他。也可以将他的地址记录下来，通过这个地址找到他。能够记录地址的数据类型就是指针。指针通过&amp;运算符来获取变量的地址。 7 位运算 &amp; 按位与运算 | 按位或运算 ^ 按位异或运算 &lt;&lt; 左移运算符，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。左移n位就是乘以2的n次方。 >&gt; 右移运算符，”&gt;&gt;”右边的数指定移动的位数，低位舍弃，高位补0。右移n位就是除以2的n次方。 用于运算构成整数的每个二进制位，就是位上0，1的运算。 8 赋值运算 = 简单的赋值运算符，将一个表达式的值赋给一个左值 += 相加后再赋值 -= 相减后再赋值 *= 相乘后再赋值 /= 相除后再赋值 %= 求余后再赋值 &lt;&lt;= 左移后赋值 >&gt;= 右移后赋值 &amp;= 按位与后赋值 ^= 按位异或后赋值 |= 按位或后赋值 变量 = 表达式=左边的变量，称之为左值。通常只能是变量。=右边的表达式，称之为右值。表达式是右值。 自赋值运算，一些运算符，可以与赋值运算符结合，完成快捷自运算赋值，就是上面的+=….|=，逻辑是：v += 1 相当于 v = v + 1其他的逻辑相同！ 9 运算符优先级由高到低，列表如下： ^ ! * / % &lt;&lt; &gt;&gt; &amp; &amp;^ + - | ^ == != &lt; &lt;= &gt;= &gt; &lt;- &amp;&amp; || 建议使用()小括号，明确调整优先级。 10 类型转换类型不同的数据不能完成运算。如果需要，则要将类型转换为一致的类型。自动转换，有些转换Go语言自动完成，例如 5/4.0 5整型会被自动转换为浮点数。强制转换，使用语法 type(数据) 的形式转换，例如：float64(5)。 Go语言对类型要求比较严格，类型可以相互转换的场景不多，主要集中在数值上。就是要类型兼容，才可以转换。 完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言的数据类型]]></title>
    <url>%2Fgo%2Fgo-type%2F</url>
    <content type="text"><![CDATA[1 概述 2 整数，int 3 浮点数，float 4 复数，complex32,complex64 5 字符，byte，rune 6 字符串，string 7 布尔型，bool 8 指针，pointer 9 数组，array 10 nil 11 切片，slice 12 映射，map 13 结构体，struct 14 接口，interface 15 函数，func() 1 概述Go语言作为类C语言，支持常规的基础数据类型的的同时，支持常用的高级数据类型。他们是： 整数，int，uint，int8，uint8，int16，uint16，int32，uint32，int64，uint64 浮点（小数），float32，float64 复数，complex 字符，byte，rune 字符串，string 布尔，bool 指针，pointor 数组，array nil 切片，slice。（引用类型） 映射，map 结构体，struct 接口，interface 函数，func() 本篇相当于一个类型索引。包含了Go语言中的全部类型。具体每种类型的操作，请参见具体章节！ 2 整数，int支持的整型分类很细，主要差异是占用的存储空间不同。基于有无符号列出为：有符号的：int，int8，int16，int32，int64无符号的：uint，uint8，uint16，uint32，uint64 其中int, unit是基于处理器架构的。意味着会根据处理器来确定是32bit还是64bit。使用时，常常使用int。或者使用int32保证兼容。在类型推导时，推导的整型为int，其他长度整型需要在定义变量时强制声明。示例：123421024-36 整型的默认值为0。 3 浮点数，float支持IEEE-754标准浮点数。支持32bit和64bit的浮点数float32和float64。在类型推导时，推导的浮点型为float64。float32需要在定义变量时强制声明。示例：12341.03.140.6184.2E10 // 4.2*10^10 浮点数的默认值为0。 4 复数，complex32,complex64原生支持复数。支持32bit+32bit复数complex64，和64bit+64bit的复数complex128。 5 字符，byte，rune使用单引号定义字符型数据，字符指的是单个字符。有两种byte和rune：byte：单字节字符，是uint8的别名。用于存储ASCII字符集字符rune：多字节字符，是int32的别名。用于存储unicode字符集字符。在类型推导时，推导的字符型为rune。byte需要在定义变量时强制声明。示例：12&apos;c&apos;&apos;康&apos; 字符的默认值是0。字符的本质就是整数型，根据字符集得到对应的字符。 6 字符串，string原生支持字符串。使用双引号(“”)或反引号(``)定义，内部是utf-8编码。双引号：””, 用于单行字符串。反引号：``，用于定义多行字符串，内部会原样解析。示例：123456789// 单行&quot;心有猛虎，细嗅蔷薇&quot;// 多行`大风歌大风起兮云飞扬。威加海内兮归故乡。安得猛士兮守四方！` 字符串支持转义字符，列表如下： \r 回车符（返回行首） \n 换行符（直接跳到下一行的同列位置） \t 制表符 \’ 单引号 \” 双引号 \\ 反斜杠 \uXXXX Unicode字符码值转义 7 布尔型，bool布尔型的值只可以是常量 true 或者 false。示例：123var ( isFinished = false ) 8 指针，pointer指针类型用于存储变量地址。使用运算符 &amp; , *完成操作。使用运算符 p:=&amp;v 可以获取v变量的地址。p中的数据格式类似0xc0000b9528，是一个内存地址的16进制表示。使用运算符 *p 可以获取指针p指向变量v的值。如图所示： 在Go语言中，指针主要用于： 类型指针，对指针指向的数据进行修改。函数调用时传递参数使用指针，避免值传递拷贝额外数据。注意类型指针不能进行偏移和运算。 切片，由指向起始元素的原始指针、元素数量和容量组成。示例：1234p := 42pv := &amp;p*pv ++// p == 43 9 数组，array数组是一段固定长度的连续内存区域。是具有相同类型数据元素序列。元素类型支持任意内置类型。数组从声明时就确定长度，可以修改数组元素，但是数组不可修改长度。使用 [长度]类型 进行数组的声明。示例：123456// 默认值初始化var nums [4]int // [0 0 0 0]// 指定初始值var position = [4]string&#123;&quot;east&quot;, &quot;south&quot;, &quot;west&quot;, &quot;north&quot;&#125;// 自动确定长度var position = [...]string&#123;&quot;east&quot;, &quot;south&quot;, &quot;west&quot;, &quot;north&quot;&#125; 会使用类型默认值初始化元素。数组不是引用类型，变量间为值传递。 可以使用range配合循环结构完成遍历，示例如下：12345678for k, v := range position &#123; fmt.Println(k, v)&#125;// 结果0 east1 south2 west3 north 10 nilnil，可以理解为未初始化引用。是以下类型的默认初始值： pointers -&gt; nil slices -&gt; nil maps -&gt; nil channels -&gt; nil functions -&gt; nil interfaces -&gt; nil 11 切片，slice切片是一个拥有相同类型元素的可变长度的序列。与数组的固定长度不同，切片也被称之为动态数组。Go提供了4中方案定义切片：1234make ( []Type ,length, capacity )make ( []Type, length)[]Type&#123;&#125;[]Type&#123;value1 , value2 , ... , valueN &#125; 或者从数组或切片生成新切片：slice [开始索引:结束索引] slice 表示目标切片对象。 开始索引和结束索引对应目标切片的索引。 不包含结束索引对应的元素 缺省开始索引，表示从头到结束索引。 缺省结束索引，表示从开始索引到末尾。 两者同时缺省时，全部切取，与切片本身等效。 两者同时为0时，等效于空切片，一般用于切片复位。12var arr = [4]string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;var sli = arr[1:3] // [&quot;b&quot;, &quot;c&quot;] 以从数组创建切片为例，理解切片，定义语法如上所示，下图为slice: 切片的实现是由一个底层数组以及其上面的动态位置，尺寸来实现。由内部由指向起始元素的指针、元素数量length和容量capacity组成。其中： 指针ptr，用于指向切片在底层数组的起始位置。 尺寸len，用于记录切片内元素数量。 容量cap，当前切片最大容量，也就是底层数组的容量。可以动态分配。 切片为引用类型。切片的默认初始值为nil。切片支持: len()尺寸, cap()容量, append()追加元素等操作。详见切片的使用。 12 映射，mapGo语言中的键值对(key-&gt;value)集合，称之为映射map。创建语法：var m = map[key_type]value_type{key1: value1, key2: value2}var m = make(map[key_type]value_type)示例,字符串型下标，字符串型值：12345678var m = make(map[string]string) //make()会分配内存空间，初始化。m[&quot;east&quot;] = &quot;东&quot;m[&quot;west&quot;] = &quot;西&quot;fmt.Println(m[&quot;east&quot;]) // 东fmt.Println(m[&quot;west&quot;]) // 西// map演示var m = map[string]string&#123;&quot;east&quot;: &quot;东&quot;, &quot;west&quot;: &quot;西&quot;&#125; 支持遍历操作，使用range：123for k, v := range mapVar &#123; fmt.Println(k, v)&#125; 映射是引用类型。详见切片操作。 13 结构体，structGo语言使用结构体来描述现实业务逻辑中实体。是自定义类型。结构体是由一系列数据构成的数据集合，一系列数据类型可以不同。定义结构体，使用struct关键字：type 结构体名 struct { 成员1 类型 成员2 类型 …}示例：12345678910111213141516171819202122232425262728293031323334// 定义Product结构type Product struct &#123; // 两个成员 name string price float64&#125;// 构造函数func newProduct(name string, price float64) *Product &#123; return &amp;Product&#123;name, price&#125;&#125;// 成员方法，接收器方式func (p *Product) getName() string &#123; return &quot;《&quot; + p.name + &quot;》&quot;&#125;// 方法2func (p *Product) setPrice(price float64) *Product &#123; p.price = price return p&#125;func main() &#123; // 构造Product型数据p1 var p1 = newProduct(&quot;BlockChain&quot;, 42.5) // 访问成员 fmt.Println(p1.name) // 通过接收器访问方法 fmt.Println(p1.getName()) var p2 = newProduct(&quot;GoLang&quot;, 30.5) p2.setPrice(44.5) fmt.Println(p2.price)&#125; 详见结构体操作。 14 接口，interface接口是一种协议，用来规范方法的调用和定义的协议，目的是保证设计的一致性，便于模块化开发以及通讯。Go语言中，也视为一种类型。定义语法：type 接口名 interface { 方法1( 参数列表 ) 返回值类型列表 方法2( 参数列表 ) 返回值类型列表 …}可以理解成没有方法体的方法。示例：1234567891011121314151617181920212223242526272829303132333435363738// 定义Product结构type Product struct &#123; // 两个成员 name string price float64 // say func()&#125;// 构造函数func newProduct(name string, price float64) *Product &#123; return &amp;Product&#123;name, price&#125;&#125;// 成员方法，接收器方式func (p *Product) getName() string &#123; return &quot;《&quot; + p.name + &quot;》&quot;&#125;// 方法2func (p *Product) setPrice(price float64) *Product &#123; p.price = price return p&#125;// 定义接口type ProductInterface interface &#123; getName() string setPrice(price float64) *Product&#125;func main() &#123; // 构造Product型数据p1 var p1 = newProduct(&quot;BlockChain&quot;, 42.5) // pi为接口，为其赋值p1，就意味着使用接口规范p1，若p1不满足接口定义则出错 var pi ProductInterface = p1 // 利用接口调用方法 fmt.Println(pi.getName())&#125; 详见接口操作 15 函数，func()Go语言中，函数可以作为数据存储变量中，此时变量为函数类型func()。可以通过该变量访问到这个函数。可以用在结构体成员定义上。语法示例：123456789101112131415func sayHello(name string) &#123; fmt.Println(&quot;Hello, &quot;, name)&#125;func main() &#123; // 函数本身就是函数类型 fmt.Printf(&quot;%T(%v)\n&quot;, sayHello, sayHello) // func(string)(0x48fe20) // 赋值给变量 var f = sayHello fmt.Printf(&quot;%T(%v)\n&quot;, f, f) // func(string)(0x48fe20) // 匿名函数也是函数类型 var af = func() &#123; &#125; fmt.Printf(&quot;%T(%v)\n&quot;, af, af) // func()(0x490080)&#125; 参见函数使用。 完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的变量]]></title>
    <url>%2Fgo%2Fgo-variable%2F</url>
    <content type="text"><![CDATA[1 概述 2 定义：声明和初始化 3 类型默认值（零值） 4 强类型 5 类型推导 6 短声明（定义） 7 批量定义 8 批量赋值 9 匿名变量 10 变量作用域 [TOC] 1 概述变量（Variable）是程序运行过程中，内容可以变化（修改）的量，变量的功能是存储用户的数据，是计算机语言中能储存计算结果或能表示值抽象概念。变量，是通过变量的标识符定位值的过程。变量的内存模拟演示： 2 定义：声明和初始化定义变使用var关键字，需要指定其类型，可以同时初始化，如果没有指定初始化值，则使用类型的默认值，语法如下：1234// 声明变量，未初始化（默认值初始化）var name string// 声明变量，特定值初始化var user string = &quot;Hank&quot; Go语言中的变量必须声明后才可以使用，不能直接使用未定义的变量。 3 类型默认值（零值）Go语言的类型默认值如下所示： 整型和浮点型变量的默认值为 0。 字符串变量的默认值为空字符串。 布尔型变量默认为 bool。 切片、函数、指针变量的默认为 nil。 4 强类型Go语言是强类型语言，变量必须有类型，同时变量仅仅可以存储特定类型的数据。 5 类型推导定义变量时，如果指定了初始值，则可以省略类型的定义，Go语言可以自己由数据推导出类型。语法为：12// 声明变量，特定值初始化，类型推导出user为字符串string型var user = &quot;Hank&quot; 6 短声明（定义）为了简化定义变量，使用运算符 := 配合类型推导，可以快速完成变量的定义，语法为：1user := &quot;hank&quot; 7 批量定义使用var或:=都可以一次性定义多个变量，语法为：var123456var ( v1 = 42 v2 = &quot;hank&quot; )也可以var v1, v2 = 42, &quot;hank&quot; :=1v1, v2 := 42, &quot;hank&quot; 推荐使用 var() 声明块语法，因为代码维护容易。 8 批量赋值一次性为多个变量进行赋值。（类似短定义。v1, v2, v3 := 42, “hank”, false）当变量定义完毕后，再批量对其赋值，没有定义功能！语法为：123456var ( v1 int v2 int)// 批量赋值v1, v2 = 42, 1024 该语法，通常配合函数的批量返回来使用，一次性接收多个返回值，语法为：12345678910111213func main() &#123; var ( v1 int v2 int ) // 调用函数，接收其返回值 v1, v2 = getData()&#125;// 返回两个值的函数func getData() (int, int) &#123; // 返回了两个值（假设42为最小值，1024为最大值） return 42, 1024&#125; 非常方便的可以交换两个变量的值：123456var ( v1 = 42 v2 = 1024)// 交换v1, v2 = v2, v1 执行后，v1==1024, v2==42 9 匿名变量标识符为（下划线）的变量，是系统保留的匿名变量，在赋值后，会被立即释放，称之为匿名变量。其作用是变量占位符，对其变量赋值结构。通常会在批量赋值时使用。例如，函数返回多个值，我们仅仅需要其中部分，则不需要的使用来占位，演示：123456789101112func main() &#123; var ( v int ) // 调用函数，仅仅需要第二个返回值，第一，三使用匿名变量占位 _, v, _ = getData()&#125;// 返回两个值的函数func getData() (int, int, int) &#123; // 返回3个值 return 42, 1024, 2012&#125; 10 变量作用域Go语言中的变量是块作用域。块，指的是使用{}定义的代码段，包括函数，if/switch/for语句，或独立的{}都是块。在块内定义的变量仅仅在本块内可用。定义，指的是 var 或者 := 定义的变量。Go语言的作用域是层叠的，就是说内层块可以直接访问到外层块的变量，前提是内层块没有定义同名的外层变量。演示如下：12345678910111213141516171819202122232425// 全局（函数外）定义3个变量var ( v1 = 1 v2 = 2 v3 = 3)func main() &#123; // main&#123;&#125;函数块，定义2个变量 var ( v2 = 22 v3 = 33 ) fmt.Println(v1, v2, v3) // 结果 1 22 33 &#123; // main()函数内部&#123;&#125;块，定义1个变量 var ( v3 = 333 ) fmt.Println(v1, v2, v3) // 结果 1 22 333 &#125;&#125; 上面代码中：在main()中，v2，v3被重新定义，则在main()中，v1是外部，而v2, v3是main函数局部的。在main()内部的{}中，v3被重新定义，则在main()内部的{}中，v1是外部，而v2是main()定义的, v3是main()内部{}定义的的。 变量可以沿内部作用域向外部作用域查找变量的过程。 带有{}的语句，其中的变量也仅仅在内部有效，例如for，if，switch等，演示：12345for i := 0; i &lt; 10; i++ &#123; fmt.Println(i)&#125;fmt.Println(i)// 会提示变量i未定义, undefined: i 注意i，是通过短声明在for内部定义的变量，仅仅在for内部有意义。 互不嵌套的{}见作用域不可见，不可互相访问。123456789func main() &#123; &#123; v := 42 &#125; &#123; fmt.Println(v) // 会提示变量v未定义, undefined: v &#125;&#125; 完！原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言中的常量]]></title>
    <url>%2Fgo%2Fgo-constant%2F</url>
    <content type="text"><![CDATA[1 概述 2 定义单个常量 3 类型推导 4 定义多个常量 5 iota迭代定义常量 6 常量在编译时确定 7 常量的作用 [TOC] 1 概述常量，一经定义不可更改的量。功能角度看，当出现不需要被更改的数据时，应该使用常量进行存储，例如圆周率。从语法的角度看，使用常量可以保证数据，在整个运行期间内，不会被更改。例如当前处理器的架构类型，可以保证不被更改。 语法如下 2 定义单个常量const 常量名 &lt;可选的类型&gt; = 常量值1const c1 int = 1000 Go语言中，标识符（常量名）是否大小写，取决于是否需要在导出时被识别。 常量的值仅仅支持，基础类型，字符串，字符，整型，浮点，布尔。 3 类型推导类型可以通过值推导出来，大多数情况可以省略类型，例如1const c2 = 1000 除非你想使用例如，int8, byte，float32这些非默认类型时，需要指定类型，例如1const c3 int16 = 1000 4 定义多个常量可以一行定义多个常量，例如：1const c4, c5 = 42, 1000 也可以使用 const()定义块，定义多个，每个常量单独一行，例如1234const ( c6 = 42 c7 = 1000) 推荐使用const()块语法，一次性定义多个。 const()块定义时，如果常量未给出定义，则延续上面的定义规则，例如：12345const ( c7 = 42 c8 // c8 = 42 c9 // c9 = 42) 此时，c8, c9, 值都是42。 5 iota迭代定义常量const配合iota关键字使用，可以定义一组由0开始+1迭代的常量演示语法：12345const ( gender_secret = iota gender_male // = iota gender_female // = iota) 此时，三个常量值，分别是,0, 1, 2iota的规则是：若iota出现在const()中，那么const()定义的第一行的iota就是0，第二行就是0+1=1，不论iota是否被常量使用。演示如下：12345678const ( c1 = 42 // iota = 0，虽然未使用iota，但后边（const()中）有使用，此时iota被初始化为0，下面每行累加1 c2 = iota // iota = 1，iota继续累加，使用了iota c3 = 1024 // iota = 2，同样未使用，但iota的值继续累加。c3 被定义为1024 c4 // iota = 3，c4延续上面的定义c4=1024，iota继续累加 c5 = iota // iota = 4，iota继续累加，使用了iota c6 = iota // iota = 5，iota继续累加，使用了iota) 此时结果为：42, 1, 1024, 1024, 4, 5 6 常量在编译时确定编译时确定，因此不能使用变量为其赋值。可以使用，确定的字面量，字面量运算，内置函数运算，其他定义常量，这些在编译时可以确定的内容为常量赋值，演示为：123456const c1 = &quot;hank&quot;const ( c2 = c1 c3 = 42 + 1024 c4 = len(&quot;hank&quot;)) 以上语法都可以！ 7 常量的作用 将特殊的值，语义化。使用时，可以知道其具体含义。 数据的集中管理，更改常量定义，即可完成全部的修改。 保证不被程序的其他代码所更改。 完！ 原文出自：小韩说课微信关注：小韩说课]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go-editor-sublime]]></title>
    <url>%2Funcategorized%2Fgo-editor-sublime%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[git中使用merge和rebase的区别]]></title>
    <url>%2Fgit%2Fgit-merge-rebase%2F</url>
    <content type="text"><![CDATA[1 需求今天和朋友讨论了一下 分支间的整合方案，merge和rebase。以及pull操作模式。下面整理如下： 2 git pull做了什么 git-pull - Fetch from and integrate with another repository or a local branch译：从另一个版本库或本地分支拉取并与其整合 文档如上说，可见pull（拉取）执行了两个操作，他们是fetch（获取）和integrate（整合）。拉取就是将版本从远程拉取到本地，可以理解成下载。而整合指的是将拉取的版本与本地版本合并到一起。这个合并的操作，通常会有两种模式来实现，就是merge和rebase。 3 git merge合并 git-merge - Join two or more development histories together译：将两个或多个开发历史合并一起 merge，合并模式。指的是合并两个分支，最终的合并代码形成一个新的版本，两个分支的版本日志按照时间顺序合并到一起即可。 演示如下，git merge dev： 合并过程是，git会自动根据两个分支的共同祖先即v2，与两个分支的最新提交即master的v6和dev的v5进行一个三方合并，然后将合并中更新的内容生成一个新的版本即v6，内容合并完成后，会成立版本日志并记录。 merge的好处是版本不会出现错乱的情况（一会可以对比rebase，你会发现有错乱的情况），但多了一个额外的版本。（其实无所谓啦）再看rebase模式。 4 git rebase变基 git-pull - Reapply commits on top of another base tip译：在另一个的基本上重新应用提交 rebase，重设基础。指的是整合时，以另一个为基础（dev），将当前的（master）应用上去。演示如下，git rebase dev： 合并过程为，git会从两个分支的共同祖先即v2开始提取当前分支即master上的提交版本即v4和v5，将提取的修改v4和v6依次应用到目标分支dev的最新提交的后面。将master指向最新的合并版本。 从合并结果上看，rebase导致版本变为了：v1-&gt;v2-&gt;v3-&gt;v5-&gt;v4-&gt;v6，与真实的版本提交时间不一致了，就是发生了错乱。但rebase不会生成新的版本。 5 merge VS rebase该如何选择他们？ 当某个分支不再需要了（例如一个本地的bug分支，修复完毕就不在需要了），那么我们选择merge是合理的。 当我们的项目重启了，代码依赖的基础发生升级了，那么我们就可以rebase到这个升级之后的基础上继续开发。 rebase -i，一个交互式的rebase，可以用来编辑版本信息，可以获得更加整洁的版本日志。 千万不要在主体分支上使用rebase，否则会导致历史胡乱的。 如果git pull的时候，出现 error: failed to push some refs to &#39;版本库&#39;， 可以git pull --rebase来解决下，后面说明原因。 这个还需要再总结一下。 6 结束有问题，欢迎留言讨论！]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客，发布到GitHub]]></title>
    <url>%2Fhexo%2Fhexo-github%2F</url>
    <content type="text"><![CDATA[1 需求博客之前是wordpress搭建的，也很好用。现在想使用一个基于markdown文件为中心的博客系统，就锁定了hexo这个项目。hexo是基于Node.js的，提供markdown支持，草稿，单页，分类，标签，主题，i18n，永久链接，静态生成，部署等很常用的博客系统功能。其主页地址为：Hexo，大家可以获取更详细的信息。下面就和大家说说过程，大致有博客搭建，部署到github，还有另一个git服务器（个人的服务器）上的过程。 下面的操作的个人电脑为windows系统（win10)。 2 hexo搭建博客此步骤完成后，可以在自己本地电脑上，看到完整的博客系统了。 2.1 快速开始在安装好 Node.js, Git的基础上，执行下面代码即可12345$ npm install -g hexo-cli$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install$ hexo server 浏览器访问http://localhost:4000，即可看到你的博客。 如果没有Node.js或Git，请按照下面的步骤执行。 2.2 安装Node.jsNode.js是基于Chrome V8 JavaScript引擎的JavaScript运行环境(runtime built)。安装方式请参考Node.js官网 ，或者本站的Node.js相关内容。安装完毕后，应出现如下效果，表示安装成功：1234C:\Users\Kang&gt; node -vv8.12.0PS C:\Users\Kang&gt; npm -v6.4.1 安装Node.js还可以使用nvm（Node Version Manager，Node.js的版本管理工具）。使用nvm可以方便的安装Node.js的各种版本，以及在版本间进行切换。安装使用方式请参考windows下的nvm和linux下的nvm或者本站的Node.js相关内容。 2.3 安装GitGit是开源免费的分布式版本控制系统是用来处理代码量由小到大相关问题的。安装方式请参考Git官网，或者本站的Git相关内容。安装完毕后，应出现如下效果，表示安装成功：12C:\Users\Kang&gt; git versiongit version 2.19.1.windows.1 2.4 安装Hexo使用npm按照hexo即可，运行如下代码全局按照hexo-cli这个hexo的命令行工具1$ npm install -g hexo-cli 安装完毕后，应出现如下效果，表示安装成功：1234567891011121314151617C:\Users\Kang&gt; hexo -vhexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 8.12.0v8: 6.2.414.66uv: 1.19.2zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.32.0napi: 3openssl: 1.0.2picu: 60.1unicode: 10.0cldr: 32.0tz: 2017c 2.5 Hexo建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 选择好需要的站点目录（目录地址不要有中文）。例如选择 D:\projects\practice\blog&gt; 作为建站目录，那么执行如下操作即可：12345C:\Users\Kang&gt; d:D:\&gt; cd .\projects\practiceD:\projects\practice&gt; hexo init blogD:\projects\practice&gt; cd blogD:\projects\practice\blog&gt; npm install 此时一个基本的博客已经建立完毕了。 2.6 运行Hexo博客进入博客目录，执行 hexo server 即可运行hexo服务器。123D:\projects\practice\blog&gt; hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 此时，浏览器访问http://localhost:4000，即可看到你的博客。效果如下： 至此，hexo搭建的博客已经完成。该博客使用方法，如何发文章，分类，标签等操作请参考Hexo文档，本文不再赘述。 3.发布到GitHubGitHub上允许我们搭建自己的静态站点，在不购买自己的服务器情况下，可以有自己的博客。需要用到Hexo提供的发布相关功能，同时需要在github上做一定的配置。 3.1 注册GitHub 已有账号的跳过此步骤 注册操作，跟着GitHub引导完成即可，GitHub注册 3.2 创建版本库登录后，创建新版本库https://github.com/new 注意：版本库名字强烈建议是 &lt;你的用户&gt;.github.io 这种格式创建完毕后，就可以使用 &lt;你的用户&gt;.github.io 这种方式访问你的github博客地址，但现在访问应该不会成功，因为是一个新创建的版本库，是空的，一无所有….。接下来就把我们本地的博客内容部署到这个github版本库上。 3.3 GitHub的SSH keys设置在部署之前，需要保证GitHub可以验证我们的机器，需要将本地的RAS-publicKey告知给GitHub，步骤如下： 3.3.1 本地RAS密钥对生成进入到 用户目录/.ssh目录下，查看是否已经存在了， 私钥id_rsa 公钥id_rsa.pub1234C:\Users\Kang&gt; cd .sshC:\Users\Kang\.ssh&gt; dir-a---- 2018/10/10 19:46 1679 id_rsa-a---- 2018/10/10 19:46 403 id_rsa.pub 上面的输出表示已经存在。若不存在，执行 ssh-keygen 生成即可（持续回车即可）：123456789101112131415161718192021C:\Users\Kang\.ssh&gt; ssh-keygen.exe -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (C:\Users\Kang/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in C:\Users\Kang/.ssh/id_rsa.Your public key has been saved in C:\Users\Kang/.ssh/id_rsa.pub.The key fingerprint is:SHA256:ymf2laAmgHVsGakavggdXrzORtVRNxkuKYq444C5Irs kang@V1N3RYQG70NI7YDThe key&apos;s randomart image is:+---[RSA 2048]----+| .. .. +o || ..o. +.. || ...=...o . || o+++.... . || +o=oo. S . ||o.=.oo . . . . ||=.o= + * o ||++..+ * . . ||Eo.. . |+----[SHA256]-----+ -t rsa 表示使用的加密类型。生成过程可以输入一些信息，简单起见，全部回车即可。 生成完毕后，目录中应该存在相应文件了。 3.3.2 告知GitHub公钥在GitHub的用户设置中，找到ssh key的设置：SSH Keys点击 New SSH Key 新建将生成的公钥id_rsa.pub内容拷贝到输入框中，起名标志即可。保存即可。此时GitHub已经和我们本地电脑建立的信任关系。我们就可以将内容发布到GitHub上了。 3.4 部署到GitHub回到我们本地的博客项目中，hexo对于基于git的部署提供了一个工具hexo-deployer-git，我们直接安装使即可。 安装 hexo-deployer-git1$ npm install hexo-deployer-git --save 3.5 修改博客的部署配置需要指定部署类型，版本库地址，分支，消息等信息12345/_config.ymldeploy: type: git repo: https://github.com/yourusername/yourusername.github.io branch: master 3.6 执行部署部署的过程，是将本地博客先生成静态文件，然后将静态文件发布到指定的版本库中。因此总的过程应该是，清理之前的静态文件，生成新静态文件，发布到版本库 这个步骤，执行下面的代码即可：12$ hexo clean$ hexo deploy 部署deploy时会自动生成，因此可以省略 $ hexo generate 操作。 第一次部署的过程中，会出现要求输入GitHub账号信息的步骤，请输入即可： 等等过后，如果出现 Deploy done，类似的信息，说明部署完成。 也可以去版本库中查看是否已经存在代码了，版本库地址就是：https://github.com/yourusername/yourusername.github.io 部署完毕，就可以在 yourusername.github.io 看到你的博客了。 3.6 绑定域名过程如下： 1 申请域名，在域名供应商申请，例如万网（阿里云）。 2 添加解析到GitHub到IP，可以通过ping yourusername.github.io 获取，例如是：185.199.109.153。在域名供应商设置，例如万网（阿里云）。 3 在版本库中，增加一个CNAME。进入yourusername.github.io版本库，右上角setting，找到 Custom domain，设置好自己的域名即可。 4 总述完成以上部署后，博客完毕。写作流程就是，本地编辑md文件，本地预览ok后，发布到github即可！写作过程，请参考：Hexo文档。 有问题，欢迎留言讨论！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go-错误处理]]></title>
    <url>%2Fgo%2Fgo-error%2F</url>
    <content type="text"><![CDATA[宕机panicGo语言可以在程序中强行宕机。宕机时会将堆栈信息和goroutine信息输出到控制台，便于处理错误。示例语法：1panic(&quot;宕机信息&quot;) 运行后，得到：123456panic: 宕机信息goroutine 1 [running]:main.main() D:/projects/practice/go/syntax.go:45 +0x40exit status 2 宕机后，后续代码不再执行。但已经 defer 入栈的语句会在宕机前完成执行。 宕机恢复 recover当发生宕机时，会被 recover 捕获。执行完对应的 defer 后，从宕机点退出当前函数后继续执行，因此程序不会崩溃。配合使用 defer 和 recover，可以从宕机中恢复并捕获错误。达到宕机后继续运行的目的。无论是由 Runtime 层抛出的 panic 崩溃，还是主动触发的 panic 崩溃。可以理解成：panic 触发宕机类似于抛出异常 thrown，recover 宕机恢复机制就对应 try/catch。原理：语法上，利用 defer 的语句会在宕机前执行的机制，在代码执行前，先定义错误处理恢复方案，加入到defer栈中。再执行需要的代码。如果代码中出现宕机，会执行已经defer的代码，就是我们的宕机恢复处理代码。演示如下：123456789101112131415161718192021222324func main() &#123; func() &#123; // 先定义错误处理恢复方案，加入到defer栈中 defer func() &#123; // 发生宕机时，获取 panic 传递的上下文 err := recover() switch err.(type) &#123; case runtime.Error: // 运行时错误 fmt.Println(&quot;Runtime error:&quot;, err) default: // 非运行时错误 fmt.Println(&quot;User error:&quot;, err) &#125; &#125;() panic(&quot;强行宕机&quot;) // 或者 var pv *int *pv = 42 &#125;() fmt.Println(&quot;after panic&quot;)&#125; 以上代码，无论执行了 panic(&quot;强行宕机&quot;) 还是 *pv = 42 都不会导致系统崩溃，而是会去执行defer的函数，输出错误信息后，继续执行。就是after panic会永远执行。因为 recover 会恢复，结束 recover 所在函数后，代码继续！1234567&gt; go run .\syntax.goUser error: 强行宕机after panic或者&gt; go run .\syntax.goRuntime error: runtime error: invalid memory address or nil pointer dereferenceafter panic]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goGuide</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go提供的常用命令]]></title>
    <url>%2Fgo%2Fgo-command%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言使用strut处理面向对象]]></title>
    <url>%2Fgo%2Fgo-stuct%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言中指针的处理]]></title>
    <url>%2Fgo%2Fgo-point%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用vim编写Go语言]]></title>
    <url>%2Fgo%2Fgo-editor-vim%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言的反射机制]]></title>
    <url>%2Fgo%2Fgo-reflect%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用goland编写Go语言]]></title>
    <url>%2Fgo%2Fgo-editor-goland%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言使用类型管道channel处理并发]]></title>
    <url>%2Fgo%2Fgo-channel%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言的内存模型]]></title>
    <url>%2Fgo%2Fgo-memory-model%2F</url>
    <content type="text"></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言中管道goroutine处理并发]]></title>
    <url>%2Fgo%2Fgo-goroutine%2F</url>
    <content type="text"><![CDATA[1 概述2 并发]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
</search>
